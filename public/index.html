<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galactic Battle</title>
    <!-- Content Security Policy: A basic policy. YOU SHOULD CUSTOMIZE THIS FOR YOUR DEPLOYMENT. -->
    <!-- This allows scripts from self, Firebase, Font Awesome, Google Fonts, and inline styles/scripts. -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://www.gstatic.com https://cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline' https://www.gstatic.com https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com; font-src 'self' https://cdnjs.cloudflare.com https://fonts.gstatic.com; connect-src 'self' https://www.gstatic.com https://firestore.googleapis.com https://securetoken.googleapis.com https://identitytoolkit.googleapis.com; img-src 'self' data:; media-src 'self';">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Google Font: Metal Mania for the title - Added font-display: swap for better loading -->
    <link href="https://fonts.googleapis.com/css2?family=Metal+Mania&display=swap" rel="stylesheet">
    <style>body{margin:0;padding:0;background:#000;display:flex;justify-content:center;align-items:center;min-height:100vh;font-family:'Courier New',monospace;color:#00ff00;overflow:hidden;}#gameContainer{position:relative;background:#000;border:2px solid #00ff00;max-width:100vw;max-height:100vh;}#gameCanvas{display:block;background:#000;max-width:100%;max-height:100%;}#ui{position:absolute;top:10px;left:10px;font-size:18px;z-index:10;}.top-right-controls{position:absolute;top:10px;right:10px;z-index:10;display:flex;gap:10px;}#soundToggle,#pauseToggle{background:#000;color:#00ff00;border:2px solid #00ff00;padding:5px 10px;cursor:pointer;font-family:'Courier New',monospace;font-size:14px;border-radius:50%;box-shadow:0 0 5px #00ff00;transition:all 0.2s ease-in-out;display:flex;align-items:center;justify-content:center;width:40px;height:40px;}#soundToggle:hover,#pauseToggle:hover{background:#00ff00;color:#000;box-shadow:0 0 15px #00ff00;}#gameOver,#levelComplete,#initialsInputContainer{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;font-size:24px;display:none;flex-direction:column;justify-content:center;align-items:center;z-index:20;background:rgba(0,0,0,0.8);padding:20px;width:80%;max-width:500px;box-sizing:border-box;border-radius:10px;border:2px solid #00ff00;box-shadow:0 0 20px #00ff00;}#gameOverTitle{font-family:'Metal Mania',cursive;font-size:48px;font-weight:bold;text-shadow:-2px -2px 0 #00ff00,2px -2px 0 #00ff00,-2px 2px 0 #00ff00,2px 2px 0 #00ff00,0 0 15px #00ff00;margin-bottom:10px;letter-spacing:2px;text-transform:uppercase;display:flex;align-items:center;justify-content:center;gap:0;cursor:pointer;transition:transform 0.2s ease-in-out;}#gameOverTitle:hover{transform:scale(1.05);}#gameOverTitle span{display:inline-block;animation:rainbow-text 9s linear infinite;text-shadow:none;}#gameOverTitle .rocket-icon{font-size:0.8em;color:#FFFFFF;text-shadow:0 0 10px #FFFFFF;animation:pulse-glow 1.5s infinite alternate;}#countdown{position:absolute;top:70%;left:50%;transform:translateX(-50%);font-size:36px;color:#ffff00;text-shadow:0 0 10px #ffff00;display:none;z-index:25;}#instructions{position:absolute;bottom:10px;left:10px;font-size:14px;color:#00aa00;z-index:5;display:none;}#gameStartOverlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);display:flex;flex-direction:column;justify-content:center;align-items:center;color:#00ff00;font-size:30px;text-shadow:0 0 10px #00ff00;z-index:30;}#gameStartOverlay #gameTitle{font-family:'Metal Mania',cursive;font-size:60px;font-weight:bold;text-shadow:-3px -3px 0 #00ff00,3px -3px 0 #00ff00,-3px 3px 0 #00ff00,3px 3px 0 #00ff00,0 0 20px #00ff00;margin-bottom:20px;letter-spacing:3px;text-transform:uppercase;display:flex;align-items:center;justify-content:center;gap:0;}#gameStartOverlay #gameTitle span{display:inline-block;animation:rainbow-text 9s linear infinite;text-shadow:none;}#gameStartOverlay #gameTitle .rocket-icon{font-size:0.8em;color:#FFFFFF;text-shadow:0 0 10px #FFFFFF;animation:pulse-glow 1.5s infinite alternate;}@keyframes pulse-glow{from{text-shadow:0 0 5px #FFFFFF,0 0 10px #FFFFFF;}to{text-shadow:0 0 15px #FFFFFF,0 0 25px #FFFFFF;}}@keyframes rainbow-text{0%{color:hsl(calc(0deg + var(--hue-offset, 0deg)), 100%, 65%);}16.67%{color:hsl(calc(60deg + var(--hue-offset, 0deg)), 100%, 65%);}33.33%{color:hsl(calc(120deg + var(--hue-offset, 0deg)), 100%, 65%);}50%{color:hsl(calc(180deg + var(--hue-offset, 0deg)), 100%, 65%);}66.67%{color:hsl(calc(240deg + var(--hue-offset, 0deg)), 100%, 65%);}83.33%{color:hsl(calc(300deg + var(--hue-offset, 0deg)), 100%, 65%);}100%{color:hsl(calc(360deg + var(--hue-offset, 0deg)), 100%, 65%);}}#gameStartOverlay div{margin:5px 0;}#gameStartOverlay .small-text{font-size:18px;color:#00aa00;}#mobileControls{position:absolute;bottom:10px;left:0;right:0;display:none;z-index:15;height:80px;}#mobileControls.show{display:flex;justify-content:space-between;align-items:center;padding:0 20px;}.control-btn{background:rgba(0,255,0,0.2);border:2px solid #00ff00;color:#00ff00;width:60px;height:60px;border-radius:50%;font-size:24px;font-weight:bold;display:flex;align-items:center;justify-content:center;user-select:none;touch-action:manipulation;}.control-btn:active{background:rgba(0,255,0,0.4);}#shootBtn{width:80px;height:80px;font-size:16px;}button{background:#000;color:#00ff00;border:2px solid #00ff00;padding:10px 20px;margin:10px;cursor:pointer;font-family:'Courier New',monospace;font-size:16px;border-radius:5px;box-shadow:0 0 5px #00ff00;transition:all 0.2s ease-in-out;}button:hover{background:#00ff00;color:#000;box-shadow:0 0 15px #00ff00;}#leaderboard{margin-top:20px;font-size:18px;max-height:300px;overflow-y:auto;border:1px solid #00aa00;padding:10px;text-align:left;width:100%;box-sizing:border-box;}#leaderboard div{padding:5px 0;border-bottom:1px dotted #00aa00;}#leaderboard div:last-child{border-bottom:none;}#initialsInput{background:rgba(0,0,0,0.5);border:1px solid #00ff00;color:#00ff00;font-family:'Courier New',monospace;font-size:20px;width:80px;text-align:center;padding:5px;margin-top:10px;text-transform:uppercase;}#keyboard{display:grid;grid-template-columns:repeat(10,1fr);gap:5px;margin-top:15px;max-width:400px;margin-left:auto;margin-right:auto;}.key-btn{background:rgba(0,255,0,0.1);border:1px solid #00ff00;color:#00ff00;padding:8px;font-size:16px;cursor:pointer;border-radius:3px;user-select:none;transition:background 0.1s;}.key-btn:active{background:rgba(0,255,0,0.3);}.key-btn.space{grid-column:span 4;}.key-btn.backspace{grid-column:span 2;}.key-btn.enter{grid-column:span 2;}@media (max-width:900px){#ui{font-size:16px;}#soundToggle,#pauseToggle{font-size:12px;padding:3px 6px;width:35px;height:35px;}#gameOver,#levelComplete,#initialsInputContainer{font-size:20px;padding:15px;}#gameOverTitle{font-size:36px;}#countdown{font-size:30px;top:65%;}#levelComplete{top:50%;}#instructions{display:none;}#gameStartOverlay #gameTitle{font-size:48px;}#gameStartOverlay{font-size:24px;}#gameStartOverlay .small-text{font-size:16px;}#leaderboard{font-size:16px;max-height:250px;}#initialsInput{font-size:18px;width:70px;}#keyboard{grid-template-columns:repeat(10,1fr);gap:3px;max-width:300px;}.key-btn{font-size:14px;padding:6px;}}@media (max-width:600px){#gameContainer{border:1px solid #00ff00;}#ui{font-size:14px;top:5px;left:5px;}#soundToggle,#pauseToggle{font-size:10px;padding:2px 4px;width:30px;height:30px;}#gameOver,#levelComplete,#initialsInputContainer{font-size:16px;padding:10px;}#gameOverTitle{font-size:28px;}#countdown{font-size:28px;top:65%;}#levelComplete{top:50%;}#leaderboard{font-size:14px;max-height:200px;}#initialsInput{font-size:16px;width:60px;}#keyboard{grid-template-columns:repeat(9,1fr);gap:2px;max-width:280px;}.key-btn{font-size:12px;padding:4px;}.key-btn.space{grid-column:span 3;}.key-btn.backspace{grid-column:span 2;}.key-btn.enter{grid-column:span 2;}}</style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Wave: <span id="wave">1</span></div>
            <div>Level: <span id="level">1</span></div>
            <div id="userIdDisplay" style="font-size:12px; color:#00aa00; margin-top:5px;">User ID: Loading...</div>
        </div>
        <div class="top-right-controls">
            <button id="pauseToggle"><i class="fas fa-pause"></i></button>
            <button id="soundToggle"><i class="fas fa-volume-up"></i></button>
        </div>
        <div id="gameOver">
            <div id="gameOverTitle">
                <span>G</span><span>a</span><span>l</span><span>a</span><span>c</span><span>t</span><span>i</span><span>c</span>
                <span class="rocket-icon"><i class="fas fa-rocket"></i></span>
                <span>B</span><span>a</span><span>t</span><span>t</span><span>l</span><span>e</span>
            </div>
            <div>GAME OVER</div>
            <div>Final Score: <span id="finalScore">0</span></div>
            <div id="leaderboard"></div>
            <div class="restart-instructions">Press SPACE or click anywhere to restart</div>
        </div>
        <div id="levelComplete">
            <div>WAVE CLEARED!</div>
            <div>Accuracy: <span id="accuracy">0%</span></div>
            <div>Accuracy Bonus: <span id="accuracyBonus">0</span></div>
            <div id="levelCompleteMessage"></div>
        </div>
        <div id="countdown"></div>
        <div id="initialsInputContainer">
            <div>NEW HIGH SCORE!</div>
            <div>Score: <span id="newHighScoreValue">0</span></div>
            <div>Enter your initials (3 chars):</div>
            <input type="text" id="initialsInput" maxlength="3" readonly>
            <div id="keyboard"></div>
            <button id="submitInitialsBtn">Submit</button>
        </div>
        <div id="gameStartOverlay">
            <div id="gameTitle">
                <span>G</span><span>a</span><span>l</span><span>a</span><span>c</span><span>t</span><span>i</span><span>c</span>
                <span class="rocket-icon"><i class="fas fa-rocket"></i></span>
                <span>B</span><span>a</span><span>t</span><span>t</span><span>l</span><span>e</span>
            </div>
            <div>Press SPACE to begin</div>
            <div class="small-text desktop-instruction">Use A/D or Arrow Keys to move</div>
            <div class="small-text desktop-instruction">SPACE to shoot</div>
            <div class="small-text desktop-instruction">P to pause/unpause</div>
            <div class="small-text" id="mobileStartInstructions" style="display: none;">Or use touch controls below</div>
        </div>
        <div id="mobileControls">
            <div class="control-btn" id="leftBtn">←</div>
            <div class="control-btn" id="shootBtn">FIRE</div>
            <div class="control-btn" id="rightBtn">→</div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, orderBy, limit, getDocs, addDoc, deleteDoc, doc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = {
            apiKey: "AIzaSyC11da8DWHKLM4poYz7bCnT7Ow84HiQnDw",
            authDomain: "space-wars-a2009.firebaseapp.com",
            projectId: "space-wars-a2009",
            storageBucket: "space-wars-a2009.firebasestorage.app",
            messagingSenderId: "47017346441",
            appId: "1:47017346441:web:5ca2177ee1ea392ff18d58",
            measurementId: "G-9N4E1T9QFS"
        };
        const initialAuthToken = null; 

        let app, db, auth, userId, highScoresCollection, isFirebaseReady = false;

        const BULLET_POOL_SIZE = 50, PARTICLE_POOL_SIZE = 200;
        const bulletPool = [], particlePool = [];
        for (let i = 0; i < BULLET_POOL_SIZE; i++) bulletPool.push({});
        for (let i = 0; i < PARTICLE_POOL_SIZE; i++) particlePool.push({});
        function getBullet() { return bulletPool.length > 0 ? bulletPool.pop() : {}; }
        function releaseBullet(bullet) { bulletPool.push(bullet); }
        function getParticle() { return particlePool.length > 0 ? particlePool.pop() : {}; }
        function releaseParticle(particle) { particlePool.push(particle); }

        class GenerativeBackgroundMusic {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.audioContext.createGain();
                this.masterGain.connect(this.audioContext.destination);
                this.masterGain.gain.value = 0.25;
                this.isPlaying = false; this.scheduledEvents = []; this.startTime = 0; this.currentLoop = 0;
                this.scales = {major: [0, 2, 4, 5, 7, 9, 11],minor: [0, 2, 3, 5, 7, 8, 10],dorian: [0, 2, 3, 5, 7, 9, 10],pentatonic: [0, 2, 4, 7, 9]};
                this.chordProgressions = [[0, 3, 5, 4],[0, 5, 3, 4],[0, 4, 1, 5],[0, 2, 3, 1],];
                this.baseFreq = 130.81;
            }
            scaleToFreq(degree, octave = 4, scaleType = 'major') {
                const scale = this.scales[scaleType];
                const semitone = scale[degree % scale.length];
                const octaveOffset = Math.floor(degree / scale.length);
                return this.baseFreq * Math.pow(2, octave + octaveOffset) * Math.pow(2, semitone / 12);
            }
            getVariation() {
                const variations = {
                    scaleType: ['major', 'minor', 'dorian', 'pentatonic'][this.currentLoop % 4],
                    tempo: 1 + (this.currentLoop % 3) * 0.1,
                    harmony: 'full',
                    bassPattern: this.currentLoop % 3,
                    padIntensity: 0.6 + (this.currentLoop % 4) * 0.1,
                    stringIntensity: 0.3 + (this.currentLoop % 3) * 0.1,
                    percussionIntensity: 0.5 + (this.currentLoop % 2) * 0.2
                };
                return variations;
            }
            createBassLine(variation) {
                const progression = this.chordProgressions[this.currentLoop % this.chordProgressions.length];
                const bassDuration = 4; const totalBassTime = progression.length * bassDuration; const loopDuration = 30;
                for (let loop = 0; loop < Math.ceil(loopDuration / totalBassTime); loop++) {
                    progression.forEach((chord, i) => {
                        const startTime = this.audioContext.currentTime + (loop * totalBassTime) + (i * bassDuration);
                        if (startTime >= this.audioContext.currentTime + loopDuration) return;
                        const pattern = variation.bassPattern;
                        const notes = pattern === 0 ? [0] : pattern === 1 ? [0, 0.5] : [0, 1, 2];
                        notes.forEach(offset => {
                            const noteTime = startTime + offset;
                            if (noteTime >= this.audioContext.currentTime + loopDuration) return;
                            this.scheduledEvents.push({time: noteTime,type: 'bass',freq: this.scaleToFreq(chord, 2, variation.scaleType),duration: 2 / variation.tempo});
                        });
                    });
                }
            }
            createPadLayers(variation) {
                const progression = this.chordProgressions[this.currentLoop % this.chordProgressions.length];
                const chordDuration = 8; const totalChordTime = progression.length * chordDuration; const loopDuration = 30;
                for (let loop = 0; loop < Math.ceil(loopDuration / totalChordTime); loop++) {
                    progression.forEach((root, i) => {
                        const startTime = this.audioContext.currentTime + (loop * totalChordTime) + (i * chordDuration);
                        if (startTime >= this.audioContext.currentTime + loopDuration) return;
                        const chordTones = [root, root + 2, root + 4, root + 6];
                        chordTones.forEach((tone, j) => {
                            if (variation.harmony === 'sparse' && j > 2) return;
                            this.scheduledEvents.push({time: startTime + j * 0.5,type: 'pad',freq: this.scaleToFreq(tone, 4, variation.scaleType),duration: chordDuration * 0.9,intensity: variation.padIntensity});
                        });
                    });
                }
            }
            createAmbientLayer() {
                const ambientInterval = 12; const loopDuration = 30;
                for (let i = 0; i < loopDuration; i += ambientInterval) {
                    const time = this.audioContext.currentTime + i + Math.random() * 4;
                    if (time >= this.audioContext.currentTime + loopDuration) break;
                    this.scheduledEvents.push({time: time,type: 'ambient',freq: this.scaleToFreq(Math.floor(Math.random() * 7), 5 + Math.floor(Math.random() * 2)),duration: 6 + Math.random() * 6});
                }
            }
            createMelodyLayer(variation) {
                const noteInterval = 3; const scale = this.scales[variation.scaleType]; const loopDuration = 30;
                for (let i = 0; i < loopDuration; i += noteInterval) {
                    if (Math.random() < 0.3) continue;
                    const time = this.audioContext.currentTime + i + Math.random() * 2;
                    if (time >= this.audioContext.currentTime + loopDuration) break;
                    const degree = Math.floor(Math.random() * scale.length);
                    this.scheduledEvents.push({time: time,type: 'melody',freq: this.scaleToFreq(degree, 5, variation.scaleType),duration: 2 + Math.random() * 3});
                }
            }
            createStringsLayer(variation) {
                const progression = this.chordProgressions[this.currentLoop % this.chordProgressions.length];
                const stringDuration = 16; const totalStringTime = progression.length * stringDuration; const loopDuration = 30;
                for (let loop = 0; loop < Math.ceil(loopDuration / totalStringTime); loop++) {
                    progression.forEach((root, i) => {
                        const startTime = this.audioContext.currentTime + (loop * totalStringTime) + (i * stringDuration);
                        if (startTime >= this.audioContext.currentTime + loopDuration) return;
                        const chordTones = [root, root + 3, root + 7];
                        chordTones.forEach(tone => {
                            this.scheduledEvents.push({time: startTime,type: 'string',freq: this.scaleToFreq(tone, 3, variation.scaleType),duration: stringDuration * 0.9,intensity: variation.stringIntensity});
                        });
                    });
                }
            }
            createPercussionLayer(variation) {
                const beatDuration = 0.5 / variation.tempo; const loopDuration = 30; const totalBeats = loopDuration / beatDuration;
                for (let i = 0; i < totalBeats; i++) {
                    const time = this.audioContext.currentTime + i * beatDuration;
                    if (time >= this.audioContext.currentTime + loopDuration) break;
                    if (i % 4 === 0 || i % 4 === 2) {this.scheduledEvents.push({time: time,type: 'kick',duration: 0.15 + Math.random() * 0.05,intensity: variation.percussionIntensity * (0.9 + Math.random() * 0.2)});
                    }if (i % 4 === 1 || i % 4 === 3) {this.scheduledEvents.push({time: time + beatDuration / 2,type: 'snare',duration: 0.15 + Math.random() * 0.05,intensity: variation.percussionIntensity * (0.9 + Math.random() * 0.2)});
                    }this.scheduledEvents.push({time: time,type: 'hihat',duration: 0.08 + Math.random() * 0.02,intensity: variation.percussionIntensity * 0.8 * (0.9 + Math.random() * 0.2)});
                    this.scheduledEvents.push({time: time + beatDuration / 2,type: 'hihat',duration: 0.08 + Math.random() * 0.02,intensity: variation.percussionIntensity * 0.8 * (0.9 + Math.random() * 0.2)});
                }
            }
            createDidgeridooLayer() {
                const droneInterval = 20; const loopDuration = 30;
                for (let i = 0; i < loopDuration; i += droneInterval) {
                    const time = this.audioContext.currentTime + i + Math.random() * 5;
                    if (time >= this.audioContext.currentTime + loopDuration) break;
                    this.scheduledEvents.push({time: time,type: 'didgeridoo',freq: 40 + Math.random() * 10,duration: 15 + Math.random() * 5});
                }
            }
            createWindLayer() {
                const windInterval = 10; const loopDuration = 30;
                for (let i = 0; i < loopDuration; i += windInterval) {
                    const time = this.audioContext.currentTime + i + Math.random() * 3;
                    if (time >= this.audioContext.currentTime + loopDuration) break;
                    this.scheduledEvents.push({time: time,type: 'wind',duration: 5 + Math.random() * 5});
                }
            }
            playNote(event) {
                const osc = this.audioContext.createOscillator(); const gain = this.audioContext.createGain(); const filter = this.audioContext.createBiquadFilter();
                switch (event.type) {
                    case 'bass': osc.type = 'triangle'; osc.frequency.value = event.freq; break;
                    case 'pad': osc.type = 'sine'; osc.frequency.value = event.freq; break;
                    case 'ambient': osc.type = 'sawtooth'; filter.type = 'lowpass'; filter.frequency.value = 800; osc.frequency.value = event.freq; break;
                    case 'melody': osc.type = 'sine'; osc.frequency.value = event.freq; break;
                    case 'string': osc.type = 'sawtooth'; osc.frequency.value = event.freq; filter.type = 'lowpass'; filter.frequency.value = 1200; break;
                    case 'kick': osc.type = 'sine'; osc.frequency.setValueAtTime(120 + Math.random() * 10, this.audioContext.currentTime); osc.frequency.exponentialRampToValueAtTime(40 + Math.random() * 5, this.audioContext.currentTime + event.duration * 0.8); break;
                    case 'snare':
                        osc.type = 'triangle'; osc.frequency.setValueAtTime(200 + Math.random() * 20, this.audioContext.currentTime); osc.frequency.exponentialRampToValueAtTime(100 + Math.random() * 10, this.audioContext.currentTime + event.duration * 0.5);
                        const snareNoise = this.audioContext.createBufferSource(); const snareBufferSize = this.audioContext.sampleRate * event.duration; const snareBuffer = this.audioContext.createBuffer(1, snareBufferSize, this.audioContext.sampleRate); const snareData = snareBuffer.getChannelData(0);
                        for (let i = 0; i < snareBufferSize; i++) snareData[i] = Math.random() * 2 - 1;
                        snareNoise.buffer = snareBuffer; const snareNoiseGain = this.audioContext.createGain(); snareNoiseGain.gain.setValueAtTime(0.5 * (event.intensity || 1), this.audioContext.currentTime); snareNoiseGain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + event.duration);
                        snareNoise.connect(snareNoiseGain); snareNoiseGain.connect(gain); snareNoise.start(this.audioContext.currentTime); snareNoise.stop(this.audioContext.currentTime + event.duration); break;
                    case 'hihat':
                        const hihatNoise = this.audioContext.createBufferSource(); const hihatBufferSize = this.audioContext.sampleRate * event.duration; const hihatBuffer = this.audioContext.createBuffer(1, hihatBufferSize, this.audioContext.sampleRate); const hihatData = hihatBuffer.getChannelData(0);
                        for (let i = 0; i < hihatBufferSize; i++) hihatData[i] = Math.random() * 2 - 1;
                        hihatNoise.buffer = hihatBuffer; const hihatFilter = this.audioContext.createBiquadFilter(); hihatFilter.type = 'highpass'; hihatFilter.frequency.value = 7000 + Math.random() * 1000;
                        hihatNoise.connect(hihatFilter); hihatFilter.connect(gain); hihatNoise.start(this.audioContext.currentTime); hihatNoise.stop(this.audioContext.currentTime + event.duration); break;
                    case 'didgeridoo':
                        osc.type = 'sine'; osc.frequency.value = event.freq; const lfo = this.audioContext.createOscillator(); const lfoGain = this.audioContext.createGain(); lfo.type = 'sine'; lfo.frequency.value = 0.5 + Math.random() * 0.5; lfoGain.gain.value = event.freq * 0.02; lfo.connect(lfoGain); lfoGain.connect(osc.frequency); lfo.start(); lfo.stop(this.audioContext.currentTime + event.duration); break;
                    case 'wind':
                        const windNoise = this.audioContext.createBufferSource(); const windBufferSize = this.audioContext.sampleRate * event.duration; const windBuffer = this.audioContext.createBuffer(1, windBufferSize, this.audioContext.sampleRate); const windData = windBuffer.getChannelData(0);
                        for (let i = 0; i < windBufferSize; i++) windData[i] = Math.random() * 2 - 1;
                        windNoise.buffer = windBuffer; const windFilter = this.audioContext.createBiquadFilter(); windFilter.type = 'lowpass'; windFilter.frequency.value = 1000 + Math.random() * 500; windFilter.Q.value = 0.5;
                        windNoise.connect(windFilter); windFilter.connect(gain); windNoise.start(this.audioContext.currentTime); windNoise.stop(this.audioContext.currentTime + event.duration); break;
                }
                let maxGain;
                switch (event.type) {
                    case 'bass': maxGain = 0.2; gain.gain.setValueAtTime(0, this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(maxGain, this.audioContext.currentTime + 0.1); gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + event.duration); break;
                    case 'pad': maxGain = (event.intensity || 0.6) * 0.08; gain.gain.setValueAtTime(0, this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(maxGain, this.audioContext.currentTime + 2); gain.gain.linearRampToValueAtTime(maxGain * 0.7, this.audioContext.currentTime + event.duration - 2); gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + event.duration); break;
                    case 'ambient': maxGain = 0.03; gain.gain.setValueAtTime(0, this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(maxGain, this.audioContext.currentTime + 1); gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + event.duration); break;
                    case 'melody': maxGain = 0.06; gain.gain.setValueAtTime(0, this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(maxGain, this.audioContext.currentTime + 0.2); gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + event.duration); break;
                    case 'string': maxGain = (event.intensity || 0.5) * 0.05; gain.gain.setValueAtTime(0, this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(maxGain, this.audioContext.currentTime + 1.5); gain.gain.linearRampToValueAtTime(maxGain * 0.8, this.audioContext.currentTime + event.duration - 1); gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + event.duration); break;
                    case 'kick': maxGain = 0.4 * (event.intensity || 1); gain.gain.setValueAtTime(maxGain, this.audioContext.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + event.duration); break;
                    case 'snare': maxGain = 0.3 * (event.intensity || 1); gain.gain.setValueAtTime(maxGain, this.audioContext.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + event.duration); break;
                    case 'hihat': maxGain = 0.2 * (event.intensity || 1); gain.gain.setValueAtTime(maxGain, this.audioContext.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + event.duration); break;
                    case 'didgeridoo': maxGain = 0.1; gain.gain.setValueAtTime(0, this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(maxGain, this.audioContext.currentTime + 1); gain.gain.exponentialRampToValueAtTime(0.005, this.audioContext.currentTime + event.duration); break;
                    case 'wind': maxGain = 0.02; gain.gain.setValueAtTime(0, this.audioContext.currentTime); gain.gain.linearRampToValueAtTime(maxGain, this.audioContext.currentTime + 2); gain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + event.duration); break;
                }
                if (event.type === 'snare' || event.type === 'hihat' || event.type === 'wind') {} else if (event.type === 'ambient' || event.type === 'string' || event.type === 'didgeridoo') {osc.connect(filter); filter.connect(gain);} else {osc.connect(gain);}
                gain.connect(this.masterGain);
                if (event.type !== 'snare' && event.type !== 'hihat' && event.type !== 'wind') {
                    osc.start();
                    if (isFinite(event.duration)) {osc.stop(this.audioContext.currentTime + event.duration);} else {console.warn(`Non-finite duration for event type ${event.type}:`, event.duration); osc.stop(this.audioContext.currentTime + 0.1);}
                }
            }
            scheduleLoop() {
                const variation = this.getVariation(); this.scheduledEvents = [];
                this.createBassLine(variation); this.createPadLayers(variation); this.createAmbientLayer(); this.createMelodyLayer(variation); this.createStringsLayer(variation); this.createPercussionLayer(variation); this.createDidgeridooLayer(); this.createWindLayer();
                this.scheduledEvents.sort((a, b) => a.time - b.time);
                this.scheduledEvents.forEach(event => {
                    const delay = (event.time - this.audioContext.currentTime) * 1000;
                    if (delay > 0) {
                        setTimeout(() => {
                            if (this.isPlaying) this.playNote(event);
                        }, delay);
                    }
                });
            }
            start() {
                if (this.isPlaying) this.stop();
                this.isPlaying = true; this.currentLoop++; this.startTime = this.audioContext.currentTime; this.scheduleLoop();
            }
            stop() {this.isPlaying = false; this.scheduledEvents = [];}
            setVolume(volume) {this.masterGain.gain.value = volume;}
            getCurrentInfo() {return {loop: this.currentLoop,variation: this.getVariation(),isPlaying: this.isPlaying};}
        }

        const backgroundMusic = new GenerativeBackgroundMusic(); let isSoundOn = true;

        function playGongSound() {
            if (!isSoundOn) return;
            const audioContext = backgroundMusic.audioContext; const osc = audioContext.createOscillator(); const gain = audioContext.createGain(); const filter = audioContext.createBiquadFilter();
            osc.type = 'sine'; osc.frequency.value = 80; filter.type = 'bandpass'; filter.frequency.value = 500; filter.Q.value = 5;
            const now = audioContext.currentTime; gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(1, now + 0.05); gain.gain.exponentialRampToValueAtTime(0.01, now + 3);
            osc.connect(filter); filter.connect(gain); gain.connect(audioContext.destination); osc.start(now); osc.stop(now + 3);
        }
        function playBonusCollectSound() {
            if (!isSoundOn) return;
            const audioContext = backgroundMusic.audioContext; const osc = audioContext.createOscillator(); const gain = audioContext.createGain(); const now = audioContext.currentTime;
            osc.type = 'sine'; osc.frequency.setValueAtTime(880, now); osc.frequency.exponentialRampToValueAtTime(1320, now + 0.1); osc.frequency.exponentialRampToValueAtTime(1760, now + 0.2);
            gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.5, now + 0.05); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.connect(gain); gain.connect(audioContext.destination); osc.start(now); osc.stop(now + 0.3);
        }
        function playRaygunSound() {
            if (!isSoundOn) return;
            const audioContext = backgroundMusic.audioContext; const osc = audioContext.createOscillator(); const gain = audioContext.createGain(); const now = audioContext.currentTime;
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(440, now); osc.frequency.exponentialRampToValueAtTime(880, now + 0.05);
            gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.connect(gain); gain.connect(audioContext.destination); osc.start(now); osc.stop(now + 0.1);
        }
        function playBazookaShotSound() {
            if (!isSoundOn) return;
            const audioContext = backgroundMusic.audioContext; const osc = audioContext.createOscillator(); const gain = audioContext.createGain(); const now = audioContext.currentTime;
            osc.type = 'square'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
            gain.gain.setValueAtTime(0.6, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.connect(gain); gain.connect(audioContext.destination); osc.start(now); osc.stop(now + 0.2);
        }
        function playBazookaExplosionSound() {
            if (!isSoundOn) return;
            const audioContext = backgroundMusic.audioContext;
            const noise = audioContext.createBufferSource(); const bufferSize = audioContext.sampleRate * 0.5; const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate); const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            noise.buffer = buffer; const noiseGain = audioContext.createGain(); noiseGain.gain.setValueAtTime(0.8, audioContext.currentTime); noiseGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
            noise.connect(noiseGain); noiseGain.connect(audioContext.destination); noise.start(audioContext.currentTime); noise.stop(audioContext.currentTime + 0.5);
            const osc = audioContext.createOscillator(); const oscGain = audioContext.createGain(); osc.type = 'sine'; osc.frequency.setValueAtTime(60, audioContext.currentTime); osc.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.4);
            oscGain.gain.setValueAtTime(0.7, audioContext.currentTime); oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.4);
            osc.connect(oscGain); oscGain.connect(audioContext.destination); osc.start(audioContext.currentTime); osc.stop(audioContext.currentTime + 0.4);
        }

        const soundToggleButton = document.getElementById('soundToggle'); const soundIcon = soundToggleButton.querySelector('i');
        soundToggleButton.addEventListener('click', async () => {
            if (backgroundMusic.audioContext.state === 'suspended') await backgroundMusic.audioContext.resume();
            isSoundOn = !isSoundOn;
            if (isSoundOn) {
                if (!gameState.paused && !gameState.showUIScreen) backgroundMusic.start();
                backgroundMusic.setVolume(0.25); soundIcon.classList.remove('fa-volume-off'); soundIcon.classList.add('fa-volume-up');
            } else {
                backgroundMusic.stop(); backgroundMusic.setVolume(0); soundIcon.classList.remove('fa-volume-up'); soundIcon.classList.add('fa-volume-off');
            }
        });

        const pauseToggleButton = document.getElementById('pauseToggle'); const pauseIcon = pauseToggleButton.querySelector('i');
        pauseToggleButton.addEventListener('click', async () => {
            if (backgroundMusic.audioContext.state === 'suspended') await backgroundMusic.audioContext.resume();
            if (gameState.paused) {
                if (player.bonusWeaponRemainingOnPause > 0) { player.bonusWeaponEndTime = Date.now() + player.bonusWeaponRemainingOnPause; player.bonusWeaponActive = true; player.bonusWeaponRemainingOnPause = 0; }
            } else {
                if (player.bonusWeaponActive) { player.bonusWeaponRemainingOnPause = player.bonusWeaponEndTime - Date.now(); player.bonusWeaponActive = false; }
            }
            gameState.paused = !gameState.paused;
            if (gameState.paused) {
                pauseIcon.classList.remove('fa-pause'); pauseIcon.classList.add('fa-play');
                if (isSoundOn) backgroundMusic.stop();
            } else {
                pauseIcon.classList.remove('fa-play'); pauseIcon.classList.add('fa-pause');
                if (isSoundOn) backgroundMusic.start();
            }
        });

        function showMessage(message, type = 'info') {
            const messageBox = document.createElement('div');
            messageBox.style.cssText = `position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);border:2px solid ${type === 'error' ? '#ff0000' : '#00ff00'};color:${type === 'error' ? '#ff0000' : '#00ff00'};padding:20px;border-radius:10px;font-size:20px;text-align:center;z-index:1000;box-shadow:0 0 20px ${type === 'error' ? '#ff0000' : '#00ff00'};`;
            messageBox.textContent = message; document.body.appendChild(messageBox);
            setTimeout(() => messageBox.remove(), 3000);
        }

        async function initFirebase() {
            try {
                app = initializeApp(firebaseConfig); db = getFirestore(app); auth = getAuth(app);
                if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken); else await signInAnonymously(auth);
                userId = auth.currentUser?.uid || crypto.randomUUID();
                document.getElementById('userIdDisplay').textContent = `User ID: ${userId}`; // Display full ID
                highScoresCollection = collection(db, `artifacts/${appId}/public/data/highscores`);
                isFirebaseReady = true;
                listenForHighScores();
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showMessage("Failed to connect to leaderboard. Please check console.", 'error');
            }
        }

        let unsubscribeHighScores = null;
        function listenForHighScores() {
            if (unsubscribeHighScores) unsubscribeHighScores();
            if (!isFirebaseReady || !highScoresCollection) return;
            const q = query(highScoresCollection, orderBy("score", "desc"), orderBy("timestamp", "asc"), limit(10));
            unsubscribeHighScores = onSnapshot(q, (snapshot) => {
                const scores = []; snapshot.forEach((doc) => scores.push({ id: doc.id, ...doc.data() }));
                displayLeaderboard(scores);
            }, (error) => {
                console.error("Error listening to high scores:", error);
                showMessage("Error loading leaderboard. Please try again.", 'error');
            });
        }

        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        let isMobile = /Android|webOS|iPhone|iPad|IEMobile|Opera Mini/i.test(navigator.userAgent) || ('ontouchstart' in window) || window.innerWidth < 900;
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 20, 800); const maxHeight = Math.min(window.innerHeight - 20, 600);
            if (isMobile) { canvas.width = maxWidth; canvas.height = maxHeight - 100; } else { canvas.width = 800; canvas.height = 600; }
        }
        resizeCanvas(); window.addEventListener('resize', resizeCanvas);
        const BOSS_EXPLOSION_ANIMATION_DURATION = 2000; const GAME_OVER_EXPLOSION_DURATION = 5000;
        const BONUS_WEAPON_WIDTH = 30; const BONUS_WEAPON_HEIGHT = 30; const BONUS_WEAPON_SPEED = 1; const BONUS_WEAPON_DURATION = 18000; const BAZOOKA_EXPLOSION_RADIUS = 70; const NORMAL_ALIEN_DROP_CHANCE = 0.005;
        let gameState = {
            score: 0, lives: 3, wave: 1, gameOver: false, levelComplete: false, keys: {}, lastShot: 0, shootDelay: 200, enemyDirection: 1, enemySpeed: 0.5,
            leftPressed: false, rightPressed: false, shootPressed: false, totalShots: 0, hits: 0, isBossWave: false, countdownTimer: 0,
            bossesDefeated: 0, gameRunning: false, paused: true, awaitingLevelTransition: false, levelTransitionStartTime: 0,
            awaitingGameOverExplosion: false, gameOverExplosionStartTime: 0, stars: [], planets: [], levelCompleteStartTime: 0,
            showUIScreen: false, bonusWeapon: null
        };
        let player = {
            x: canvas.width / 2 - 15, y: canvas.height - 60, originalY: canvas.height - 60, width: 30, height: 20, speed: 5,
            invincible: false, invincibleTimer: 0, flashToggle: false, bonusWeaponActive: false, currentBonusWeaponType: null,
            bonusWeaponEndTime: 0, bonusWeaponRemainingOnPause: 0,
        };
        let bullets = [], enemies = [], enemyBullets = [], particles = [], boss = null, minions = [], drones = [], currentHighScores = [];
        const explosionColors = ['#FF0000', '#FFFF00', '#00FFFF', '#FF00FF', '#00FF00', '#FFFFFF', '#FFA500', '#8A2BE2'];
        function initBackground() {
            gameState.stars = [];
            for (let i = 0; i < 200; i++) gameState.stars.push({x: Math.random() * canvas.width,y: Math.random() * canvas.height,size: Math.random() * 2 + 0.5,speed: Math.random() * 0.5 + 0.1,color: `rgba(255, 255, 255, ${Math.random() * 0.8 + 0.2})`});
            gameState.planets = [];
            const planetColors = ['#FFD700','#00FF00','#87CEEB','#9370DB','#00BFFF','#00CED1','#3CB371','#DA70D6','#ADFF2F','#4682B4','#F0E68C','#EE82EE','#8B008B','#00FF7F','#40E0D0','#20B2AA','#6495ED','#7B68EE'];
            for (let i = 0; i < 12; i++) gameState.planets.push({x: Math.random() * canvas.width,y: Math.random() * canvas.height,radius: Math.random() * 10 + 5,speed: Math.random() * 0.8 + 0.2,color: planetColors[Math.floor(Math.random() * planetColors.length)],type: Math.floor(Math.random() * 2)});
        }
        function createEnemies() {
            enemies = []; const rows = 5; const cols = 10; const enemyWidth = 24; const enemyHeight = 16; const spacing = 40; const startX = 100; const startY = 60;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    enemies.push({x: startX + col * spacing,y: startY + row * spacing,width: enemyWidth,height: enemyHeight,type: row < 2 ? 'small' : row < 4 ? 'medium' : 'large',points: row < 2 ? 30 : row < 4 ? 20 : 10});
                }
            }
        }
        function getBossProperties(wave) {
            const bossLevel = Math.floor((wave - 1) / 3); const initialHP = 5; const hpIncreaseFactor = 1.05; const speedIncreaseFactor = 1.05; const shootDelayDecreaseFactor = 0.95;
            return {
                hp: Math.floor(initialHP * Math.pow(hpIncreaseFactor, bossLevel)),
                speed: 1 + (bossLevel * 0.5), bulletSpeed: 4 + (bossLevel * 0.5),
                shootDelay: Math.max(200, 1000 * Math.pow(shootDelayDecreaseFactor, bossLevel)),
                drawType: (bossLevel % 11), bulletType: (bossLevel % 3)
            };
        }
        function createBoss() {
            const bossProps = getBossProperties(gameState.wave);
            boss = {
                x: canvas.width / 2 - 40, y: 50, width: 80, height: 40, hp: bossProps.hp, speed: bossProps.speed,
                bulletSpeed: bossProps.bulletSpeed, shootDelay: bossProps.shootDelay, lastShot: 0, direction: 1,
                drawType: bossProps.drawType, bulletType: bossProps.bulletType, behaviorTimer: 0
            };
            gameState.isBossWave = true; createMinions(); spawnBonusWeapon(boss.x + boss.width / 2, boss.y + boss.height / 2);
        }
        function spawnBonusWeapon(x = Math.random() * (canvas.width - BONUS_WEAPON_WIDTH), y = -BONUS_WEAPON_HEIGHT) {
            const weaponTypes = ['raygun', 'bazooka', 'shield', 'timeslow', 'homing', 'drone', 'scoremultiplier'];
            const randomType = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
            gameState.bonusWeapon = {x: x,y: y,width: BONUS_WEAPON_WIDTH,height: BONUS_WEAPON_HEIGHT,speed: BONUS_WEAPON_SPEED,type: randomType};
        }
        function createMinions() {
            minions = []; const minionWidth = 20; const minionHeight = 15;
            minions.push({x: boss.x + boss.width / 2 - minionWidth * 2,y: boss.y + boss.height + 10,width: minionWidth,height: minionHeight,speed: 2,type: 'minion',points: 50});
            minions.push({x: boss.x + boss.width / 2 - minionWidth / 2,y: boss.y + boss.height + 10,width: minionWidth,height: minionHeight,speed: 2,type: 'minion',points: 50});
            minions.push({x: boss.x + boss.width / 2 + minionWidth,y: boss.y + boss.height + 10,width: minionWidth,height: minionHeight,speed: 2,type: 'minion',points: 50});
        }
        function createParticles(x, y, colors = ['#ff0000'], num = 12, speed = 8, life = 60, size = 3) {
            for (let i = 0; i < num; i++) {
                const p = getParticle();
                p.x = x; p.y = y; p.vx = (Math.random() - 0.5) * speed; p.vy = (Math.random() - 0.5) * speed;
                p.life = life; p.maxLife = life; p.color = colors[Math.floor(Math.random() * colors.length)]; p.size = Math.random() * size + 2;
                particles.push(p);
            }
        }
        function gameLoop() {
            if (gameState.paused) { draw(); requestAnimationFrame(gameLoop); return; }
            update(); draw(); requestAnimationFrame(gameLoop);
        }
        function update() {
            gameState.stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0; star.x = Math.random() * canvas.width;
                }
            });
            gameState.planets.forEach(planet => {
                planet.y += planet.speed;
                if (planet.y > canvas.height + planet.radius) {
                    planet.y = -planet.radius; planet.x = Math.random() * canvas.width;
                }
            });
            if (gameState.awaitingGameOverExplosion) {
                particles = particles.filter(p => {
                    p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98; p.life--; return p.life > 0;
                });
                if (Date.now() - gameState.gameOverExplosionStartTime >= GAME_OVER_EXPLOSION_DURATION) {
                    gameState.awaitingGameOverExplosion = false; endGame();
                }
                return;
            }
            if (gameState.awaitingLevelTransition) {
                particles = particles.filter(p => {
                    p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98; p.life--; return p.life > 0;
                });
                if (Date.now() - gameState.levelTransitionStartTime >= BOSS_EXPLOSION_ANIMATION_DURATION) {
                    gameState.awaitingLevelTransition = false; levelComplete();
                }
                return;
            }
            if (gameState.gameOver || !gameState.gameRunning || gameState.showUIScreen) return;
            if (gameState.levelComplete) {
                const elapsed = Date.now() - gameState.levelCompleteStartTime;
                const duration = gameState.countdownTimer * 1000;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    player.y = player.originalY - (Math.sin(progress * Math.PI) * 50);
                } else {
                    player.y = player.originalY;
                }
            }
            if (!gameState.levelComplete && !gameState.showUIScreen) {
                if (player.invincible && Date.now() - player.invincibleTimer > 2000) {
                    player.invincible = false; player.flashToggle = false;
                }
                if (player.invincible) player.flashToggle = Math.floor(Date.now() / 100) % 2 === 0;
                const isGameActive = !gameState.paused && !gameState.levelComplete && !gameState.showUIScreen;
                if (player.bonusWeaponActive && isGameActive && Date.now() > player.bonusWeaponEndTime) {
                    player.bonusWeaponActive = false; player.currentBonusWeaponType = null; drones = []; showMessage("Bonus expired!", 'info');
                }
                if (gameState.bonusWeapon) {
                    gameState.bonusWeapon.y += gameState.bonusWeapon.speed;
                    if (gameState.bonusWeapon.y > canvas.height) gameState.bonusWeapon = null;
                    if (gameState.bonusWeapon && player.x < gameState.bonusWeapon.x + gameState.bonusWeapon.width && player.x + player.width > gameState.bonusWeapon.x && player.y < gameState.bonusWeapon.y + gameState.bonusWeapon.height && player.y + player.height > gameState.bonusWeapon.y) {
                        if (player.bonusWeaponActive) player.bonusWeaponRemainingOnPause = player.bonusWeaponEndTime - Date.now(); else player.bonusWeaponRemainingOnPause = 0;
                        player.bonusWeaponActive = true; player.currentBonusWeaponType = gameState.bonusWeapon.type; player.bonusWeaponEndTime = Date.now() + BONUS_WEAPON_DURATION; player.bonusWeaponRemainingOnPause = 0;
                        gameState.bonusWeapon = null; playBonusCollectSound(); showMessage(`BONUS: ${player.currentBonusWeaponType.toUpperCase()}!`, 'info');
                        if (player.currentBonusWeaponType === 'drone') drones = [{ x: player.x, y: player.y, lastShot: 0, shootDelay: 500 }];
                    }
                }
                let speedFactor = 1;
                if (player.bonusWeaponActive && player.currentBonusWeaponType === 'timeslow') speedFactor = 0.5;
                if (gameState.keys['ArrowLeft'] || gameState.keys['a'] || gameState.keys['A'] || gameState.leftPressed) player.x = Math.max(0, player.x - player.speed);
                if (gameState.keys['ArrowRight'] || gameState.keys['d'] || gameState.keys['D'] || gameState.rightPressed) player.x = Math.min(canvas.width - player.width, player.x + player.speed);
                if ((gameState.keys[' '] || gameState.shootPressed) && Date.now() - gameState.lastShot > gameState.shootDelay) {
                    if (player.bonusWeaponActive) {
                        if (player.currentBonusWeaponType === 'raygun') {
                            bullets.push({ x: player.x + player.width / 2 - 1, y: player.y, width: 2, height: 10, speed: 7, vx: -1.5, type: 'raygun' });
                            bullets.push({ x: player.x + player.width / 2 - 1, y: player.y, width: 2, height: 10, speed: 7, vx: 0, type: 'raygun' });
                            bullets.push({ x: player.x + player.width / 2 - 1, y: player.y, width: 2, height: 10, speed: 7, vx: 1.5, type: 'raygun' });
                            playRaygunSound();
                        } else if (player.currentBonusWeaponType === 'bazooka') {
                            bullets.push({ x: player.x + player.width / 2 - 2, y: player.y, width: 4, height: 15, speed: 8, type: 'bazooka' });
                            playBazookaShotSound();
                        } else if (player.currentBonusWeaponType === 'homing') {
                            bullets.push({ x: player.x + player.width / 2 - 2, y: player.y, width: 4, height: 15, speed: 5, type: 'homing' });
                        } else {
                            bullets.push({ x: player.x + player.width / 2 - 1, y: player.y, width: 2, height: 10, speed: 7, type: 'normal' });
                        }
                    } else {
                        bullets.push({ x: player.x + player.width / 2 - 1, y: player.y, width: 2, height: 10, speed: 7, type: 'normal' });
                    }
                    gameState.lastShot = Date.now(); gameState.totalShots++;
                }
                bullets = bullets.filter(bullet => {
                    if (bullet.type === 'homing') {
                        let target = null; let minDist = Infinity;
                        [...enemies, boss, ...minions].filter(e => e).forEach(entity => {
                            const dist = Math.sqrt(Math.pow(bullet.x - entity.x, 2) + Math.pow(bullet.y - entity.y, 2));
                            if (dist < minDist) { minDist = dist; target = entity; }
                        });
                        if (target) {
                            const angle = Math.atan2(target.y - bullet.y, target.x - bullet.x);
                            bullet.vx = Math.cos(angle) * bullet.speed; bullet.vy = Math.sin(angle) * bullet.speed;
                        } else {
                            bullet.vy = -bullet.speed; bullet.vx = 0;
                        }
                    }
                    bullet.y -= bullet.speed;
                    if (bullet.vx) bullet.x += bullet.vx;
                    return bullet.y > -bullet.height && bullet.x > -bullet.width && bullet.x < canvas.width;
                });
                enemyBullets = enemyBullets.filter(bullet => {
                    bullet.y += bullet.speed * speedFactor; return bullet.y < canvas.height;
                });
                if (enemies.length > 0 && Math.random() < 0.002 * gameState.wave) {
                    const shooter = enemies[Math.floor(Math.random() * enemies.length)];
                    enemyBullets.push({ x: shooter.x + shooter.width / 2 - 4, y: shooter.y + shooter.height, width: 8, height: 16, speed: 4 });
                }
                if (boss) {
                    boss.speed_actual = boss.speed * speedFactor;
                    switch (boss.drawType) {
                        case 0: boss.x += boss.direction * boss.speed_actual; if (boss.x <= 0 || boss.x + boss.width >= canvas.width) boss.direction *= -1; break;
                        case 1: boss.x += boss.direction * boss.speed_actual * 1.5; if (boss.x <= 0 || boss.x + boss.width >= canvas.width) boss.direction *= -1; boss.behaviorTimer++; if (boss.behaviorTimer % (120 / speedFactor) === 0) { boss.y += (Math.random() - 0.5) * 20; boss.y = Math.max(20, Math.min(canvas.height / 3, boss.y)); } break;
                        case 2: boss.x = canvas.width / 2 + Math.sin(Date.now() * 0.001 * speedFactor) * 50 - boss.width / 2; break;
                        case 3: boss.x += boss.direction * boss.speed_actual * 2; if (boss.x <= 0 || boss.x + boss.width >= canvas.width) boss.direction *= -1; break;
                        case 4: boss.y += boss.direction * boss.speed_actual * 0.5; if (boss.y <= 20 || boss.y + boss.height >= canvas.height / 2) boss.direction *= -1; break;
                        case 5: boss.x += boss.direction * boss.speed_actual; boss.y += boss.direction * boss.speed_actual * 0.5; if (boss.x <= 0 || boss.x + boss.width >= canvas.width) boss.direction *= -1; if (boss.y <= 20 || boss.y + boss.height >= canvas.height / 2) { boss.y = Math.max(20, Math.min(canvas.height / 2 - boss.height, boss.y)); boss.direction *= -1; } break;
                        case 6: boss.x = canvas.width / 2 + Math.cos(Date.now() * 0.0008 * speedFactor) * (canvas.width / 4) - boss.width / 2; boss.y = canvas.height / 4 + Math.sin(Date.now() * 0.0008 * speedFactor) * (canvas.height / 8) - boss.height / 2; break;
                        case 7: if (boss.behaviorTimer < (180 / speedFactor)) { boss.x += boss.direction * boss.speed_actual * 3; if (boss.x <= 0 || boss.x + boss.width >= canvas.width) boss.direction *= -1; } else if (boss.behaviorTimer < (240 / speedFactor)) {} else { boss.behaviorTimer = 0; } boss.behaviorTimer++; break;
                        case 8: if (player.x < boss.x) boss.x -= Math.min(boss.speed_actual * 0.5, boss.x - player.x); else if (player.x > boss.x) boss.x += Math.min(boss.speed_actual * 0.5, player.x - boss.x); break;
                        case 9: boss.behaviorTimer++; if (boss.behaviorTimer % (120 / speedFactor) === 0) { boss.x = Math.random() * (canvas.width - boss.width); boss.y = 20 + Math.random() * (canvas.height / 3 - boss.height); } break;
                        case 10: boss.x = canvas.width / 2 + Math.sin(Date.now() * 0.0005 * speedFactor) * (canvas.width / 3) - boss.width / 2; boss.y = 50 + Math.cos(Date.now() * 0.0003 * speedFactor) * (canvas.height / 6); break;
                    }
                    if (Date.now() - boss.lastShot > (boss.shootDelay / speedFactor)) {
                        switch (boss.bulletType) {
                            case 0: enemyBullets.push({ x: boss.x + boss.width / 2 - 4, y: boss.y + boss.height, width: 8, height: 16, speed: boss.bulletSpeed }); break;
                            case 1: enemyBullets.push({ x: boss.x + boss.width / 2 - 10, y: boss.y + boss.height, width: 8, height: 16, speed: boss.bulletSpeed, vx: -1 }); enemyBullets.push({ x: boss.x + boss.width / 2 - 4, y: boss.y + boss.height, width: 8, height: 16, speed: boss.bulletSpeed, vx: 0 }); enemyBullets.push({ x: boss.x + boss.width / 2 + 2, y: boss.y + boss.height, width: 8, height: 16, speed: boss.bulletSpeed, vx: 1 }); break;
                            case 2: let targetX = player.x + player.width / 2; let bulletVX = (targetX - (boss.x + boss.width / 2)) / (canvas.height - boss.y) * boss.bulletSpeed; enemyBullets.push({ x: boss.x + boss.width / 2 - 4, y: boss.y + boss.height, width: 8, height: 16, speed: boss.bulletSpeed, vx: bulletVX }); break;
                        }
                        boss.lastShot = Date.now();
                    }
                }
                enemyBullets.forEach(bullet => { if (bullet.vx) bullet.x += bullet.vx; });
                minions.forEach(minion => {
                    minion.speed_actual = minion.speed * speedFactor;
                    if (boss) minion.x += boss.direction * minion.speed_actual; else minion.y += minion.speed_actual * 0.5;
                    if (Math.random() < 0.01 * speedFactor) enemyBullets.push({ x: minion.x + minion.width / 2 - 4, y: minion.y + minion.height, width: 8, height: 16, speed: minion.speed + 1 });
                });
                if (player.bonusWeaponActive && player.currentBonusWeaponType === 'drone') {
                    drones.forEach(drone => {
                        drone.x = player.x + player.width / 2 - 10; drone.y = player.y - 30;
                        if (Date.now() - drone.lastShot > drone.shootDelay) {
                            bullets.push({ x: drone.x + 5, y: drone.y, width: 2, height: 10, speed: 7, type: 'normal' });
                            drone.lastShot = Date.now();
                        }
                    });
                } else { drones = []; }
                let moveDown = false;
                if (!gameState.isBossWave && enemies.length > 0) {
                    let leftmost = Math.min(...enemies.map(e => e.x));
                    let rightmost = Math.max(...enemies.map(e => e.x + e.width));
                    if (leftmost <= 0 && gameState.enemyDirection === -1) {
                        gameState.enemyDirection = 1; moveDown = true;
                    } else if (rightmost >= canvas.width && gameState.enemyDirection === 1) {
                        gameState.enemyDirection = -1; moveDown = true;
                    }
                    enemies.forEach(enemy => { enemy.x += gameState.enemyDirection * gameState.enemySpeed * speedFactor; });
                    if (moveDown) enemies.forEach(enemy => { enemy.y += 15; });
                }
                bullets.forEach((bullet, bulletIndex) => {
                    enemies.forEach((enemy, enemyIndex) => {
                        if (bullet.x < enemy.x + enemy.width && bullet.x + bullet.width > enemy.x && bullet.y < enemy.y + enemy.height && bullet.y + enemy.height > enemy.y) {
                            if (bullet.type === 'bazooka') {
                                playBazookaExplosionSound(); createParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, explosionColors, 50, 15, 120, 7); bullets.splice(bulletIndex, 1);
                                const explodedEnemies = [];
                                enemies.forEach((e, idx) => {
                                    const dist = Math.sqrt(Math.pow((e.x + e.width / 2) - (enemy.x + enemy.width / 2), 2) + Math.pow((e.y + e.height / 2) - (enemy.y + e.height / 2), 2));
                                    if (dist <= BAZOOKA_EXPLOSION_RADIUS) explodedEnemies.push(idx);
                                });
                                explodedEnemies.sort((a, b) => b - a).forEach(idx => {
                                    if (Math.random() < NORMAL_ALIEN_DROP_CHANCE) spawnBonusWeapon(enemies[idx].x + enemies[idx].width / 2, enemies[idx].y + enemies[idx].height / 2);
                                    let scoreMultiplier = (player.bonusWeaponActive && player.currentBonusWeaponType === 'scoremultiplier') ? 2 : 1;
                                    gameState.score += enemies[idx].points * scoreMultiplier; enemies.splice(idx, 1); gameState.hits++;
                                });
                            } else {
                                createParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                if (Math.random() < NORMAL_ALIEN_DROP_CHANCE) spawnBonusWeapon(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                                let scoreMultiplier = (player.bonusWeaponActive && player.currentBonusWeaponType === 'scoremultiplier') ? 2 : 1;
                                gameState.score += enemy.points * scoreMultiplier; bullets.splice(bulletIndex, 1); enemies.splice(enemyIndex, 1); gameState.hits++;
                            }
                        }
                    });
                    if (boss && bullet.x < boss.x + boss.width && bullet.x + boss.width > boss.x && bullet.y < boss.y + boss.height && bullet.y + boss.height > boss.y) {
                        if (bullet.type === 'bazooka' || bullet.type === 'raygun' || bullet.type === 'homing') {
                            boss.hp = 0; bullets.splice(bulletIndex, 1); gameState.hits++;
                        } else {
                            boss.hp--; bullets.splice(bulletIndex, 1); gameState.hits++;
                        }
                        if (boss.hp <= 0) {
                            playGongSound(); createParticles(boss.x + boss.width / 2, boss.y + boss.height / 2, explosionColors, 30, 10, 180, 5);
                            gameState.bossesDefeated++;
                            if (gameState.bossesDefeated > 0 && gameState.bossesDefeated % 3 === 0) {
                                gameState.lives++; showMessage("EXTRA LIFE!", 'info');
                            }
                            boss = null; gameState.isBossWave = false; gameState.awaitingLevelTransition = true; gameState.levelTransitionStartTime = Date.now(); return;
                        }
                    }
                    minions.forEach((minion, minionIndex) => {
                        if (bullet.x < minion.x + minion.width && bullet.x + minion.width > minion.x && bullet.y < minion.y + minion.height && bullet.y + minion.height > minion.y) {
                            if (bullet.type === 'bazooka') {
                                bullets.splice(bulletIndex, 1); playBazookaExplosionSound(); createParticles(minion.x + minion.width / 2, minion.y + minion.height / 2, explosionColors, 20, 8, 60, 4);
                            } else {
                                createParticles(minion.x + minion.width / 2, minion.y + minion.height / 2, ['#ffcc00', '#ffaa00']);
                                let scoreMultiplier = (player.bonusWeaponActive && player.currentBonusWeaponType === 'scoremultiplier') ? 2 : 1;
                                gameState.score += minion.points * scoreMultiplier; bullets.splice(bulletIndex, 1); minions.splice(minionIndex, 1); gameState.hits++;
                            }
                        }
                    });
                });
                enemyBullets.forEach((bullet, bulletIndex) => {
                    if (player.bonusWeaponActive && player.currentBonusWeaponType === 'shield') {
                        if (bullet.x < player.x + player.width && bullet.x + bullet.width > player.x && bullet.y < player.y + player.height && bullet.y + player.height > player.y) {
                            enemyBullets.splice(bulletIndex, 1); createParticles(bullet.x, bullet.y, ['#00FFFF', '#FFFFFF'], 5, 3, 20, 2);
                        }
                        return;
                    }
                    if (!player.invincible && bullet.x < player.x + player.width && bullet.x + bullet.width > player.x && bullet.y < player.y + player.height && bullet.y + player.height > player.y) {
                        createParticles(player.x + player.width / 2, player.y + player.height / 2, ['#00ff00', '#00aa00']);
                        gameState.lives--; enemyBullets.splice(bulletIndex, 1);
                        player.invincible = true; player.invincibleTimer = Date.now();
                        if (gameState.lives <= 0) {
                            gameState.awaitingGameOverExplosion = true; gameState.gameOverExplosionStartTime = Date.now();
                            createParticles(player.x + player.width / 2, player.y + player.height / 2, explosionColors, 30, 10, 300, 5);
                            player.x = -1000; player.y = -1000; gameState.gameRunning = false;
                        }
                    }
                });
                enemies.forEach(enemy => {
                    if (enemy.y + enemy.height >= player.y - 10) {
                        if (!gameState.awaitingGameOverExplosion) {
                            gameState.lives = 0; gameState.awaitingGameOverExplosion = true; gameState.gameOverExplosionStartTime = Date.now();
                            createParticles(player.x + player.width / 2, player.y + player.height / 2, explosionColors, 30, 10, 300, 5);
                            player.x = -1000; player.y = -1000; gameState.gameRunning = false;
                        }
                    }
                });
            }
            particles = particles.filter(p => { p.x += p.vx; p.y += p.vy; p.vx *= 0.98; p.vy *= 0.98; p.life--; return p.life > 0; });
            if (enemies.length === 0 && !boss && minions.length === 0 && !gameState.levelComplete && !gameState.awaitingLevelTransition) {
                if (gameState.wave % 3 === 0) {} else { levelComplete(); }
            }
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('level').textContent = gameState.bossesDefeated + 1;
        }
        function drawBackground() {
            gameState.stars.forEach(star => { ctx.fillStyle = star.color; ctx.fillRect(star.x, star.y, star.size, star.size); });
            gameState.planets.forEach(planet => {
                ctx.fillStyle = planet.color; ctx.beginPath(); ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2); ctx.fill();
                if (planet.type === 1) {
                    ctx.strokeStyle = '#AAAAAA'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(planet.x, planet.y, planet.radius * 1.5, planet.radius * 0.3, Math.PI / 4, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 1;
                }
            });
        }
        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            if (!gameState.awaitingGameOverExplosion && !gameState.showUIScreen) {
                if (!player.invincible || (player.invincible && player.flashToggle)) {
                    const rocketX = player.x, rocketY = player.y - 10, rocketWidth = player.width, rocketHeight = player.height + 15;
                    ctx.fillStyle = '#CCCCCC'; ctx.beginPath(); ctx.moveTo(rocketX + rocketWidth * 0.25, rocketY); ctx.lineTo(rocketX + rocketWidth * 0.75, rocketY); ctx.lineTo(rocketX + rocketWidth, rocketY + rocketHeight * 0.8); ctx.lineTo(rocketX, rocketY + rocketHeight * 0.8); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#6699FF'; ctx.beginPath(); ctx.moveTo(rocketX + rocketWidth * 0.25, rocketY); ctx.lineTo(rocketX + rocketWidth * 0.75, rocketY); ctx.lineTo(rocketX + rocketWidth / 2, rocketY - rocketHeight * 0.3); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#333333'; ctx.beginPath(); ctx.arc(rocketX + rocketWidth / 2, rocketY + rocketHeight * 0.3, rocketWidth * 0.15, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#DDDDDD'; ctx.beginPath(); ctx.arc(rocketX + rocketWidth / 2, rocketY + rocketHeight * 0.3, rocketWidth * 0.1, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#6699FF'; ctx.beginPath(); ctx.moveTo(rocketX, rocketY + rocketHeight * 0.7); ctx.lineTo(rocketX - rocketWidth * 0.3, rocketY + rocketHeight); ctx.lineTo(rocketX + rocketWidth * 0.1, rocketY + rocketHeight); ctx.closePath(); ctx.fill();
                    ctx.beginPath(); ctx.moveTo(rocketX + rocketWidth, rocketY + rocketHeight * 0.7); ctx.lineTo(rocketX + rocketWidth * 1.3, rocketY + rocketHeight); ctx.lineTo(rocketX + rocketWidth * 0.9, rocketY + rocketHeight); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#FF8800'; ctx.beginPath(); ctx.moveTo(rocketX + rocketWidth * 0.3, rocketY + rocketHeight * 0.8); ctx.lineTo(rocketX + rocketWidth * 0.7, rocketY + rocketHeight * 0.8); ctx.lineTo(rocketX + rocketWidth / 2, rocketY + rocketHeight * 1.2); ctx.closePath(); ctx.fill();
                    ctx.fillStyle = '#FFFF00'; ctx.beginPath(); ctx.moveTo(rocketX + rocketWidth * 0.4, rocketY + rocketHeight * 0.9); ctx.lineTo(rocketX + rocketWidth * 0.6, rocketY + rocketHeight * 0.9); ctx.lineTo(rocketX + rocketWidth / 2, rocketY + rocketHeight * 1.1); ctx.closePath(); ctx.fill();
                    if (player.bonusWeaponActive && player.currentBonusWeaponType) {
                        ctx.font = `900 20px "Font Awesome 6 Free"`; ctx.fillStyle = '#FFD700'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        const iconX = player.x + player.width / 2; const iconY = player.y - 5;
                        switch (player.currentBonusWeaponType) {
                            case 'raygun': ctx.fillText('\uf06b', iconX, iconY); break;
                            case 'bazooka': ctx.fillText('\uf1e2', iconX, iconY); break;
                            case 'shield': ctx.fillText('\uf132', iconX, iconY); break;
                            case 'timeslow': ctx.fillText('\uf017', iconX, iconY); break;
                            case 'homing': ctx.fillText('\uf140', iconX, iconY); break;
                            case 'drone': ctx.fillText('\uf87b', iconX, iconY); break;
                            case 'scoremultiplier': ctx.fillText('\uf530', iconX, iconY); break;
                        }
                        ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                    }
                    if (player.bonusWeaponActive && player.currentBonusWeaponType === 'shield') {
                        const time = Date.now() * 0.005;
                        const shieldRadius = player.width * 0.8 + Math.sin(time * 5) * 5;
                        ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(time * 3) * 0.3})`;
                        ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(player.x + player.width / 2, player.y + player.height / 2, shieldRadius, 0, Math.PI * 2); ctx.stroke(); ctx.lineWidth = 1;
                    }
                }
            }
            if (!gameState.paused && !gameState.awaitingLevelTransition && !gameState.awaitingGameOverExplosion && !gameState.showUIScreen) {
                if (gameState.bonusWeapon) {
                    const bw = gameState.bonusWeapon; const iconSize = bw.width * 0.8; const time = Date.now() * 0.001;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(time * 5) * 0.3})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(bw.x + bw.width / 2, bw.y + bw.height / 2, bw.width * 0.6 * (1 + Math.sin(time * 3) * 0.1), 0, Math.PI * 2); ctx.stroke();
                    const gradient = ctx.createLinearGradient(bw.x, bw.y, bw.x + bw.width, bw.y + bw.height);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.sin(time * 7) * 0.2})`); gradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.1 + Math.sin(time * 7 + Math.PI) * 0.2})`); gradient.addColorStop(1, `rgba(255, 255, 255, ${0.3 + Math.sin(time * 7) * 0.2})`);
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(bw.x + bw.width / 2, bw.y + bw.height / 2, bw.width * 0.5, 0, Math.PI * 2); ctx.fill();
                    ctx.font = `900 ${iconSize}px "Font Awesome 6 Free"`; ctx.fillStyle = '#FFFFFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    switch (bw.type) {
                        case 'raygun': ctx.fillText('\uf06b', bw.x + bw.width / 2, bw.y + bw.height / 2 + 2); break;
                        case 'bazooka': ctx.fillText('\uf1e2', bw.x + bw.width / 2, bw.y + bw.height / 2 + 2); break;
                        case 'shield': ctx.fillText('\uf132', bw.x + bw.width / 2, bw.y + bw.height / 2 + 2); break;
                        case 'timeslow': ctx.fillText('\uf017', bw.x + bw.width / 2, bw.y + bw.height / 2 + 2); break;
                        case 'homing': ctx.fillText('\uf140', bw.x + bw.width / 2, bw.y + bw.height / 2 + 2); break;
                        case 'drone': ctx.fillText('\uf87b', bw.x + bw.width / 2, bw.y + bw.height / 2 + 2); break;
                        case 'scoremultiplier': ctx.fillText('\uf530', bw.x + bw.width / 2, bw.y + bw.height / 2 + 2); break;
                    }
                    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
                }
                ctx.fillStyle = '#ffff00';
                bullets.forEach(bullet => {
                    if (bullet.type === 'raygun') {
                        ctx.fillStyle = '#00FFFF'; ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height * 1.5);
                    } else if (bullet.type === 'bazooka') {
                        ctx.fillStyle = '#FF4500'; ctx.fillRect(bullet.x, bullet.y, bullet.width * 2, bullet.height * 1.5);
                        ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(Date.now() * 0.02) * 0.5})`; ctx.fillRect(bullet.x + bullet.width/2 - 2, bullet.y + bullet.height, 4, 10);
                    } else if (bullet.type === 'homing') {
                        ctx.fillStyle = '#FF00FF'; ctx.fillRect(bullet.x, bullet.y, bullet.width * 1.5, bullet.height * 1.5);
                        ctx.fillStyle = `rgba(255, 0, 255, ${0.5 + Math.sin(Date.now() * 0.02) * 0.5})`; ctx.fillRect(bullet.x + bullet.width/2 - 1, bullet.y + bullet.height, 2, 5);
                    } else {
                        ctx.fillStyle = '#ffff00'; ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    }
                });
                enemies.forEach(enemy => {
                    switch (enemy.type) {
                        case 'small': ctx.fillStyle = '#ff0000'; break;
                        case 'medium': ctx.fillStyle = '#ff8800'; break;
                        case 'large': ctx.fillStyle = '#ffff00'; break;
                    }
                    ctx.fillRect(enemy.x, enemy.y + 4, enemy.width, enemy.height - 4);
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(enemy.x + 6, enemy.y, 2, 6); ctx.fillRect(enemy.x + enemy.width - 8, enemy.y, 2, 6);
                    ctx.fillRect(enemy.x + 4, enemy.y - 1, 2, 2); ctx.fillRect(enemy.x + 8, enemy.y - 1, 2, 2); ctx.fillRect(enemy.x + enemy.width - 10, enemy.y - 1, 2, 2); ctx.fillRect(enemy.x + enemy.width - 6, enemy.y - 1, 2, 2);
                    ctx.fillStyle = '#000'; ctx.fillRect(enemy.x + 4, enemy.y + 8, 4, 4); ctx.fillRect(enemy.x + enemy.width - 8, enemy.y + 8, 4, 4);
                    ctx.fillStyle = '#00ff00'; ctx.fillRect(enemy.x - 2, enemy.y + 8, 3, 6); ctx.fillRect(enemy.x + enemy.width - 1, enemy.y + 8, 3, 6);
                    ctx.fillRect(enemy.x + 4, enemy.y + enemy.height - 2, 3, 6); ctx.fillRect(enemy.x + enemy.width - 7, enemy.y + enemy.height - 2, 3, 6);
                });
                if (boss) {
                    const time = Date.now() * 0.001;
                    function interpolateColor(color1, color2, factor) {
                        const result = color1.slice();
                        for (let i = 0; i < 3; i++) result[i] = Math.round(result[i] + factor * (color2[i] - color1[i]));
                        return `rgb(${result[0]}, ${result[1]}, ${result[2]})`;
                    }
                    switch (boss.drawType) {
                        case 0:
                            const colorPhase0 = Math.sin(time * 2) * 0.5 + 0.5; const bodyColor0 = interpolateColor([153, 0, 255], [0, 255, 204], colorPhase0);
                            ctx.fillStyle = bodyColor0; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width / 2, boss.height / 2, 0, 0, Math.PI * 2); ctx.fill();
                            const coreSize0 = boss.width * 0.2 * (1 + Math.sin(time * 5) * 0.1);
                            ctx.fillStyle = `rgba(0, 255, 204, ${0.8 + Math.sin(time * 3) * 0.2})`; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2, coreSize0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#cccccc'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2 - 10, boss.width / 4, boss.height / 4, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#555555'; ctx.fillRect(boss.x - 5, boss.y + boss.height / 2 - 5, 10, 10); ctx.fillRect(boss.x + boss.width - 5, boss.y + boss.height / 2 - 5, 10, 10); ctx.fillRect(boss.x - 10, boss.y + boss.height / 2 - 2, 10, 4); ctx.fillRect(boss.x + boss.width, boss.y + boss.height / 2 - 2, 10, 4);
                            ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(time * 10) * 0.5})`; ctx.beginPath(); ctx.arc(boss.x - 10, boss.y + boss.height / 2, 3, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width + 10, boss.y + boss.height / 2, 3, 0, Math.PI * 2); ctx.fill();
                            break;
                        case 1:
                            const colorPhase1 = Math.sin(time * 1.5) * 0.5 + 0.5; const bodyColor1 = interpolateColor([255, 68, 68], [255, 165, 0], colorPhase1);
                            ctx.fillStyle = bodyColor1; ctx.beginPath(); ctx.moveTo(boss.x + boss.width / 2, boss.y); ctx.lineTo(boss.x + boss.width, boss.y + boss.height / 2); ctx.lineTo(boss.x + boss.width / 2, boss.y + boss.height); ctx.lineTo(boss.x, boss.y + boss.height / 2); ctx.closePath(); ctx.fill();
                            ctx.save(); ctx.translate(boss.x + boss.width / 2, boss.y + boss.height / 2); ctx.rotate(time * 0.5); ctx.fillStyle = '#ffff00'; ctx.fillRect(-boss.width * 0.15, -boss.height * 0.15, boss.width * 0.3, boss.height * 0.3); ctx.restore();
                            ctx.fillStyle = `rgba(0, 255, 255, ${0.3 + Math.sin(time * 8) * 0.7})`; ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.2, boss.y + boss.height * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.8, boss.y + boss.height * 0.2, 3, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.2, boss.y + boss.height * 0.8, 3, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.8, boss.y + boss.height * 0.8, 3, 0, Math.PI * 2); ctx.fill();
                            break;
                        case 2:
                            const numSides = 8; const radius = boss.width / 2; const centerX = boss.x + boss.width / 2; const centerY = boss.y + boss.height / 2;
                            ctx.fillStyle = '#8888ff'; ctx.beginPath();
                            for (let i = 0; i < numSides; i++) {
                                const angle = (i * 2 * Math.PI / numSides) - (Math.PI / numSides);
                                const x = centerX + radius * Math.cos(angle); const y = centerY + radius * Math.sin(angle);
                                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                            }
                            ctx.closePath(); ctx.fill();
                            ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.arc(centerX, centerY, radius * 0.4, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#000000'; const pupilOffsetX = Math.sin(time * 3) * 5; const pupilOffsetY = Math.cos(time * 2.5) * 5;
                            ctx.beginPath(); ctx.arc(centerX + pupilOffsetX, centerY + pupilOffsetY, radius * 0.2, 0, Math.PI * 2); ctx.fill();
                            ctx.strokeStyle = '#aaaaaa'; ctx.lineWidth = 2; const antennaLength = 15 + Math.sin(time * 7) * 5;
                            ctx.beginPath(); ctx.moveTo(centerX - 10, centerY - radius * 0.8); ctx.lineTo(centerX - 10 - 5, centerY - radius * 0.8 - antennaLength); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(centerX + 10, centerY - radius * 0.8); ctx.lineTo(centerX + 10 + 5, centerY - radius * 0.8 - antennaLength); ctx.stroke(); ctx.lineWidth = 1;
                            break;
                        case 3:
                            ctx.fillStyle = '#444444'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width * 0.6, boss.height * 0.4, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#66CCFF'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.2, boss.width * 0.3, 0, Math.PI, true); ctx.fill();
                            const lightPulse = 0.5 + Math.sin(time * 10) * 0.5;
                            ctx.fillStyle = `rgba(255, 215, 0, ${lightPulse})`; ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.2, boss.y + boss.height / 2, 5, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.4, boss.y + boss.height / 2, 5, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.6, boss.y + boss.height / 2, 5, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.8, boss.y + boss.height / 2, 5, 0, Math.PI * 2); ctx.fill();
                            const glowAlpha = 0.7 + Math.sin(time * 8) * 0.3;
                            ctx.fillStyle = `rgba(255, 100, 0, ${glowAlpha})`; ctx.fillRect(boss.x + boss.width * 0.25, boss.y + boss.height * 0.8, 10, 15); ctx.fillRect(boss.x + boss.width * 0.75 - 10, boss.y + boss.height * 0.8, 10, 15);
                            break;
                        case 4:
                            ctx.fillStyle = '#FF8C00'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width * 0.5, boss.height * 0.3, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#ADD8E6'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.1, boss.width * 0.4, Math.PI, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.3, boss.y + boss.height * 0.7, 8, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.7, boss.y + boss.height * 0.7, 8, 0, Math.PI * 2); ctx.fill();
                            ctx.save(); ctx.translate(boss.x + boss.width / 2, boss.y + boss.height / 2); ctx.rotate(time * 0.7); ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                            ctx.beginPath(); ctx.arc(0, 0, boss.width * 0.15, 0, Math.PI * 2); ctx.fill();
                            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, boss.width * 0.15, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); ctx.lineWidth = 1;
                            break;
                        case 5:
                            ctx.fillStyle = '#8A2BE2'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width * 0.55, boss.height * 0.35, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#FF6347'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.15, boss.width * 0.3, 0, Math.PI, true); ctx.fill();
                            ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 5; ctx.beginPath();
                            const startY5 = boss.y + boss.height * 0.6; const zigzagHeight5 = 10; const segmentWidth5 = 12;
                            for (let x = boss.x + 5; x < boss.x + boss.width - 5; x += segmentWidth5) {
                                if ((Math.floor(x / segmentWidth5)) % 2 === 0) ctx.lineTo(x, startY5); else ctx.lineTo(x, startY5 + zigzagHeight5);
                            }
                            ctx.stroke(); ctx.lineWidth = 1;
                            const weaponGlow = 0.5 + Math.sin(time * 12) * 0.5;
                            ctx.fillStyle = `rgba(0, 255, 255, ${weaponGlow})`; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height * 0.9, 10, 0, Math.PI * 2); ctx.fill();
                            break;
                        case 6:
                            ctx.fillStyle = '#A9A9A9'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2 + 5, boss.width * 0.5, boss.height * 0.2, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#ADD8E6'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.1, boss.width * 0.25, Math.PI, Math.PI * 2); ctx.fill();
                            const alienOffsetY = Math.sin(time * 4) * 2;
                            ctx.fillStyle = '#32CD32'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.25 + alienOffsetY, boss.width * 0.12, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#FFFFFF'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 - 7, boss.y + boss.height / 2 - boss.height * 0.28 + alienOffsetY, 4, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 + 7, boss.y + boss.height / 2 - boss.height * 0.28 + alienOffsetY, 4, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 - 7, boss.y + boss.height / 2 - boss.height * 0.28 + alienOffsetY, 2, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 + 7, boss.y + boss.height / 2 - boss.height * 0.28 + alienOffsetY, 2, 0, Math.PI * 2); ctx.fill();
                            const beamAlpha = 0.3 + Math.sin(time * 6) * 0.2;
                            ctx.fillStyle = `rgba(255, 255, 0, ${beamAlpha})`; ctx.beginPath(); ctx.moveTo(boss.x + boss.width / 2 - 10, boss.y + boss.height); ctx.lineTo(boss.x + boss.width / 2 + 10, boss.y + boss.height); ctx.lineTo(boss.x + boss.width / 2 + 20, boss.y + boss.height + 40); ctx.lineTo(boss.x + boss.width / 2 - 20, boss.y + boss.height + 40); ctx.closePath(); ctx.fill();
                            break;
                        case 7:
                            ctx.fillStyle = '#32CD32'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2 + 10, boss.width * 0.4, boss.height * 0.3, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#FF0000'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 + 15, boss.width * 0.2, 0, Math.PI, false); ctx.fill();
                            ctx.fillStyle = '#FFFFFF'; ctx.fillRect(boss.x + boss.width / 2 - 15, boss.y + boss.height / 2 + 10, 5, 5); ctx.fillRect(boss.x + boss.width / 2 - 5, boss.y + boss.height / 2 + 10, 5, 5); ctx.fillRect(boss.x + boss.width / 2 + 5, boss.y + boss.height / 2 + 10, 5, 5); ctx.fillRect(boss.x + boss.width / 2 + 10, boss.y + boss.height / 2 + 10, 5, 5);
                            ctx.strokeStyle = '#32CD32'; ctx.lineWidth = 5;
                            for (let i = 0; i < 5; i++) {
                                ctx.beginPath(); ctx.moveTo(boss.x + boss.width / 2, boss.y + boss.height / 2);
                                const tentacleOffsetX = (i - 2) * 35; const tentacleOffsetY = -60 + Math.sin(time * 5 + i) * 10;
                                ctx.quadraticCurveTo(boss.x + boss.width / 2 + tentacleOffsetX, boss.y + tentacleOffsetY, boss.x + boss.width / 2 + (i - 2) * 60, boss.y - 90 + Math.sin(time * 5 + i) * 15); ctx.stroke();
                                const eyeGlow = 0.5 + Math.sin(time * 10 + i) * 0.5;
                                ctx.fillStyle = `rgba(255, 255, 255, ${eyeGlow})`; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 + (i - 2) * 60, boss.y - 90 + Math.sin(time * 5 + i) * 15, 10, 0, Math.PI * 2); ctx.fill();
                                ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 + (i - 2) * 60, boss.y - 90 + Math.sin(time * 5 + i) * 15, 5, 0, Math.PI * 2); ctx.fill();
                            }
                            ctx.lineWidth = 1;
                            break;
                        case 8:
                            ctx.fillStyle = '#FF69B4'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width * 0.45, boss.height * 0.45, 0, 0, Math.PI * 2); ctx.fill();
                            const eyeShiftX = Math.sin(time * 2) * 3; const eyeShiftY = Math.cos(time * 3) * 2;
                            ctx.fillStyle = '#FFFFFF'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 - 15 + eyeShiftX, boss.y + boss.height / 2 - 10 + eyeShiftY, 12, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 + 15 + eyeShiftX, boss.y + boss.height / 2 - 10 + eyeShiftY, 12, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 - 15 + eyeShiftX, boss.y + boss.height / 2 - 10 + eyeShiftY, 6, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 + 15 + eyeShiftX, boss.y + boss.height / 2 - 10 + eyeShiftY, 6, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#DAA520'; ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.3 + Math.sin(time) * 2, boss.y + boss.height * 0.6, 9, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.7 + Math.cos(time) * 2, boss.y + boss.height * 0.6, 11, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.5, boss.y + boss.height * 0.8 + Math.sin(time * 1.5) * 2, 8, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.2, boss.y + boss.height * 0.4, 6, 0, Math.PI * 2); ctx.fill();
                            break;
                        case 9:
                            ctx.fillStyle = '#B0C4DE'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width * 0.55, boss.height * 0.25, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#6A5ACD'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.1, boss.width * 0.3, Math.PI, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#00FFFF'; ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.2, boss.y + boss.height * 0.55, 4, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.8, boss.y + boss.height * 0.55, 4, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.4, boss.y + boss.height * 0.65, 4, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width * 0.6, boss.y + boss.height * 0.65, 4, 0, Math.PI * 2); ctx.fill();
                            const flameHeight = 15 + Math.sin(time * 15) * 5;
                            ctx.fillStyle = `rgba(255, 165, 0, ${0.7 + Math.sin(time * 10) * 0.3})`; ctx.beginPath(); ctx.moveTo(boss.x + boss.width * 0.2, boss.y + boss.height * 0.7); ctx.lineTo(boss.x + boss.width * 0.3, boss.y + boss.height * 0.7 + flameHeight); ctx.lineTo(boss.x + boss.width * 0.7, boss.y + boss.height * 0.7 + flameHeight); ctx.lineTo(boss.x + boss.width * 0.8, boss.y + boss.height * 0.7); ctx.closePath(); ctx.fill();
                            break;
                        case 10:
                            ctx.fillStyle = '#A9A9A9'; ctx.beginPath(); ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2 + 5, boss.width * 0.5, boss.height * 0.2, 0, 0, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#ADD8E6'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.1, boss.width * 0.25, Math.PI, Math.PI * 2); ctx.fill();
                            ctx.fillStyle = '#32CD32'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.25, boss.width * 0.12, 0, Math.PI * 2); ctx.fill();
                            const blinkFactor = (Math.sin(time * 5) > 0.8) ? 0 : 1;
                            ctx.fillStyle = '#000000'; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 - 7, boss.y + boss.height / 2 - boss.height * 0.28, 3 * blinkFactor, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.3, 3 * blinkFactor, 0, Math.PI * 2); ctx.fill();
                            ctx.beginPath(); ctx.arc(boss.x + boss.width / 2 + 7, boss.y + boss.height / 2 - boss.height * 0.28, 3 * blinkFactor, 0, Math.PI * 2); ctx.fill();
                            ctx.strokeStyle = '#000000'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2 - boss.height * 0.15, 10, 0, Math.PI, true); ctx.stroke(); ctx.lineWidth = 1;
                            const crackOffset = Math.sin(time * 8) * 1;
                            ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(boss.x + boss.width / 2 + 10 + crackOffset, boss.y + boss.height / 2 - boss.height * 0.15 + crackOffset); ctx.lineTo(boss.x + boss.width / 2 + 15 - crackOffset, boss.y + boss.height / 2 - boss.height * 0.25 - crackOffset); ctx.stroke();
                            break;
                    }
                    ctx.fillStyle = '#ff0000';
                    const initialBossHP = getBossProperties(gameState.wave).hp;
                    const hpBarWidth = boss.width * (boss.hp / initialBossHP);
                    ctx.fillRect(boss.x, boss.y - 10, hpBarWidth, 5);
                }
                minions.forEach(minion => {
                    ctx.fillStyle = '#00ffff'; ctx.fillRect(minion.x, minion.y, minion.width, minion.height);
                    ctx.fillRect(minion.x + minion.width/4, minion.y - 5, minion.width/2, 5);
                });
                ctx.fillStyle = '#ff0000';
                enemyBullets.forEach(bullet => { ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height); });
                drones.forEach(drone => {
                    ctx.fillStyle = '#AAAAAA'; ctx.beginPath(); ctx.arc(drone.x, drone.y, 8, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#00FF00'; ctx.beginPath(); ctx.arc(drone.x, drone.y + 5, 3, 0, Math.PI * 2); ctx.fill();
                });
                if (player.bonusWeaponActive && player.currentBonusWeaponType === 'scoremultiplier') {
                    ctx.font = 'bold 24px "Courier New", monospace'; ctx.fillStyle = `rgba(255, 215, 0, ${0.8 + Math.sin(Date.now() * 0.005) * 0.2})`; ctx.textAlign = 'center'; ctx.fillText('2X SCORE!', canvas.width / 2, 30); ctx.textAlign = 'left';
                }
                if (player.bonusWeaponActive && player.currentBonusWeaponType === 'timeslow') {
                    const time = Date.now() * 0.001;
                    ctx.fillStyle = `rgba(0, 100, 255, ${0.1 + Math.sin(time * 2) * 0.05})`; ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }
            if (gameState.awaitingGameOverExplosion || gameState.awaitingLevelTransition) {
                particles.forEach(p => {
                    ctx.fillStyle = p.color; ctx.globalAlpha = p.life / p.maxLife; ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
                });
                ctx.globalAlpha = 1;
            }
        }
        function endGame() {
            gameState.gameOver = true; gameState.gameRunning = false;
            enemies = []; enemyBullets = []; bullets = []; boss = null; minions = []; particles = []; gameState.bonusWeapon = null; drones = [];
            if (player.bonusWeaponActive) { player.bonusWeaponRemainingOnPause = player.bonusWeaponEndTime - Date.now(); player.bonusWeaponActive = false; }
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('gameOver').style.display = 'flex'; gameState.showUIScreen = true;
            checkHighScore(gameState.score);
            if (isSoundOn) backgroundMusic.stop();
            animateTitle('gameOverTitle'); addGameOverRestartListeners();
        }
        function levelComplete() {
            gameState.levelComplete = true; gameState.gameRunning = false; gameState.levelCompleteStartTime = Date.now();
            if (player.bonusWeaponActive) { player.bonusWeaponRemainingOnPause = player.bonusWeaponEndTime - Date.now(); player.bonusWeaponActive = false; }
            let accuracy = (gameState.totalShots === 0) ? 0 : ((gameState.hits / gameState.totalShots) * 100).toFixed(1);
            let accuracyBonus = Math.floor(parseFloat(accuracy) * 10); gameState.score += accuracyBonus;
            document.getElementById('accuracy').textContent = accuracy + '%';
            document.getElementById('accuracyBonus').textContent = accuracyBonus;
            document.getElementById('levelComplete').style.display = 'block';
            if (gameState.wave % 3 === 0) document.getElementById('levelCompleteMessage').textContent = `CONGRATULATIONS!!! LEVEL ${gameState.bossesDefeated} COMPLETED`;
            else document.getElementById('levelCompleteMessage').textContent = `Wave Cleared! Next wave in...`;
            gameState.countdownTimer = 3;
            if (gameState.wave % 3 === 0) gameState.countdownTimer = 5;
            document.getElementById('countdown').textContent = gameState.countdownTimer;
            document.getElementById('countdown').style.display = 'block';
            const countdownInterval = setInterval(() => {
                gameState.countdownTimer--;
                document.getElementById('countdown').textContent = gameState.countdownTimer;
                if (gameState.countdownTimer <= 0) {
                    clearInterval(countdownInterval); document.getElementById('levelComplete').style.display = 'none';
                    document.getElementById('countdown').style.display = 'none'; nextLevel();
                }
            }, 1000);
        }
        function nextLevel() {
            gameState.wave++; gameState.totalShots = 0; gameState.hits = 0; gameState.levelComplete = false; gameState.gameRunning = true;
            bullets = []; enemyBullets = []; particles = []; boss = null; minions = []; gameState.bonusWeapon = null; drones = [];
            if (player.bonusWeaponRemainingOnPause > 0) { player.bonusWeaponEndTime = Date.now() + player.bonusWeaponRemainingOnPause; player.bonusWeaponActive = true; player.bonusWeaponRemainingOnPause = 0; }
            if (gameState.wave % 3 === 0) createBoss(); else createEnemies();
            if (isSoundOn) backgroundMusic.start();
        }
        function restartGame() {
            gameState = {
                score: 0, lives: 3, wave: 1, gameOver: false, levelComplete: false,
                keys: {}, lastShot: 0, shootDelay: 200, enemyDirection: 1, enemySpeed: 0.5,
                leftPressed: false, rightPressed: false, shootPressed: false,
                totalShots: 0, hits: 0, isBossWave: false, countdownTimer: 0,
                bossesDefeated: 0, gameRunning: false, paused: true,
                awaitingLevelTransition: false, levelTransitionStartTime: 0,
                awaitingGameOverExplosion: false, gameOverExplosionStartTime: 0,
                stars: [], planets: [], levelCompleteStartTime: 0,
                showUIScreen: false, bonusWeapon: null
            };
            player = {
                x: canvas.width / 2 - 15, y: canvas.height - 60, originalY: canvas.height - 60, width: 30, height: 20, speed: 5,
                invincible: false, invincibleTimer: 0, flashToggle: false,
                bonusWeaponActive: false, currentBonusWeaponType: null,
                bonusWeaponEndTime: 0, bonusWeaponRemainingOnPause: 0,
            };
            bullets = []; enemyBullets = []; particles = []; boss = null; minions = []; drones = [];
            initBackground(); createEnemies();
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('initialsInputContainer').style.display = 'none';
            document.getElementById('gameStartOverlay').style.display = 'flex';
            pauseIcon.classList.remove('fa-play'); pauseIcon.classList.add('fa-pause');
            backgroundMusic.stop(); removeGameOverRestartListeners();
        }
        async function checkHighScore(score) {
            if (!isFirebaseReady || !highScoresCollection) {
                showMessage("Leaderboard not ready. Please check console.", 'error');
                document.getElementById('gameOver').style.display = 'flex'; return;
            }
            try {
                const q = query(highScoresCollection, orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                currentHighScores = [];
                querySnapshot.forEach((doc) => currentHighScores.push({ id: doc.id, ...doc.data() }));
                const isNewHighScore = currentHighScores.length < 10 || score > (currentHighScores.length > 0 ? currentHighScores[currentHighScores.length - 1].score : -1);
                if (isNewHighScore) {
                    document.getElementById('gameOver').style.display = 'none';
                    document.getElementById('newHighScoreValue').textContent = score;
                    document.getElementById('initialsInput').value = '';
                    document.getElementById('initialsInputContainer').style.display = 'block';
                    document.getElementById('initialsInput').focus(); gameState.showUIScreen = true;
                } else {
                    document.getElementById('gameOver').style.display = 'flex';
                }
            } catch (error) {
                console.error("Error checking high score:", error);
                showMessage("Error checking high score. Please check console.", 'error');
                document.getElementById('gameOver').style.display = 'flex';
            }
        }
        async function submitInitials() {
            const initialsInput = document.getElementById('initialsInput');
            let initials = initialsInput.value.trim().toUpperCase();
            if (initials.length !== 3) {
                showMessage("Please enter exactly 3 initials.", 'error'); return;
            }
            if (!isFirebaseReady || !highScoresCollection) {
                showMessage("Leaderboard not ready. Please try again.", 'error'); return;
            }
            try {
                await addDoc(highScoresCollection, {
                    initials: initials, score: gameState.score, timestamp: Date.now()
                });
                document.getElementById('initialsInputContainer').style.display = 'none';
                document.getElementById('gameOver').style.display = 'flex'; gameState.showUIScreen = true;
            } catch (e) {
                console.error("Error adding document: ", e);
                showMessage("Failed to save score. Please try again.", 'error');
            }
        }
        function displayLeaderboard(scores) {
            const leaderboardDiv = document.getElementById('leaderboard');
            leaderboardDiv.innerHTML = '';
            if (scores.length === 0) {
                leaderboardDiv.innerHTML = '<div>No scores yet!</div>'; return;
            }
            scores.forEach((s, index) => {
                const scoreEntry = document.createElement('div');
                const displayInitials = s.initials ? String(s.initials).substring(0, 3).toUpperCase() : '---';
                const displayScore = typeof s.score === 'number' ? s.score : 0;
                scoreEntry.textContent = `${index + 1}. ${displayInitials} - ${displayScore}`;
                leaderboardDiv.appendChild(scoreEntry);
            });
            currentHighScores = scores;
        }
        let gameOverRestartHandler = null;
        function addGameOverRestartListeners() {
            removeGameOverRestartListeners();
            gameOverRestartHandler = (e) => {
                if (gameState.gameOver) {
                    if (e.type === 'keydown' && e.key === ' ') {
                        e.preventDefault(); restartGame();
                    } else if (e.type === 'click' || e.type === 'touchstart') {
                        restartGame();
                    }
                }
            };
            const gameOverScreen = document.getElementById('gameOver');
            gameOverScreen.addEventListener('click', gameOverRestartHandler);
            gameOverScreen.addEventListener('touchstart', gameOverRestartHandler);
            document.addEventListener('keydown', gameOverRestartHandler);
        }
        function removeGameOverRestartListeners() {
            if (gameOverRestartHandler) {
                const gameOverScreen = document.getElementById('gameOver');
                gameOverScreen.removeEventListener('click', gameOverRestartHandler);
                gameOverScreen.removeEventListener('touchstart', gameOverRestartHandler);
                document.removeEventListener('keydown', gameOverRestartHandler);
                gameOverRestartHandler = null;
            }
        }
        document.addEventListener('keydown', async (e) => {
            gameState.keys[e.key] = true;
            if (gameState.paused && e.key === ' ') {
                gameState.paused = false; document.getElementById('gameStartOverlay').style.display = 'none';
                gameState.gameRunning = true; gameState.showUIScreen = false;
                if (player.bonusWeaponRemainingOnPause > 0) { player.bonusWeaponEndTime = Date.now() + player.bonusWeaponRemainingOnPause; player.bonusWeaponActive = true; player.bonusWeaponRemainingOnPause = 0; }
                pauseIcon.classList.remove('fa-play'); pauseIcon.classList.add('fa-pause');
                if (isSoundOn) {
                    if (backgroundMusic.audioContext.state === 'suspended') { await backgroundMusic.audioContext.resume(); backgroundMusic.start(); backgroundMusic.setVolume(0.25); }
                    else { backgroundMusic.start(); backgroundMusic.setVolume(0.25); }
                }
                e.preventDefault(); return;
            }
            if (e.key.toLowerCase() === 'p' && !gameState.gameOver && !gameState.showUIScreen) {
                if (!gameState.awaitingLevelTransition && !gameState.awaitingGameOverExplosion) {
                    if (backgroundMusic.audioContext.state === 'suspended') await backgroundMusic.audioContext.resume();
                    if (gameState.paused) {
                        if (player.bonusWeaponRemainingOnPause > 0) { player.bonusWeaponEndTime = Date.now() + player.bonusWeaponRemainingOnPause; player.bonusWeaponActive = true; player.bonusWeaponRemainingOnPause = 0; }
                    } else {
                        if (player.bonusWeaponActive) { player.bonusWeaponRemainingOnPause = player.bonusWeaponEndTime - Date.now(); player.bonusWeaponActive = false; }
                    }
                    gameState.paused = !gameState.paused;
                    if (gameState.paused) {
                        pauseIcon.classList.remove('fa-pause'); pauseIcon.classList.add('fa-play');
                        if (isSoundOn) backgroundMusic.stop();
                    } else {
                        pauseIcon.classList.remove('fa-play'); pauseIcon.classList.add('fa-pause');
                        if (isSoundOn) backgroundMusic.start();
                    }
                    e.preventDefault();
                }
            }
            if (document.getElementById('initialsInputContainer').style.display === 'block') {
                const input = document.getElementById('initialsInput');
                if (e.key.match(/^[a-zA-Z]$/) && input.value.length < 3) input.value += e.key.toUpperCase();
                else if (e.key === 'Backspace') input.value = input.value.slice(0, -1);
                else if (e.key === 'Enter') submitInitials();
                e.preventDefault();
            }
        });
        document.addEventListener('keyup', (e) => { gameState.keys[e.key] = false; });
        function setupMobileControls() {
            if (isMobile) {
                document.getElementById('mobileControls').classList.add('show');
                document.getElementById('gameStartOverlay').querySelector('#mobileStartInstructions').style.display = 'block';
                document.querySelectorAll('#gameStartOverlay .desktop-instruction').forEach(el => el.style.display = 'block');
                const leftBtn = document.getElementById('leftBtn'); const rightBtn = document.getElementById('rightBtn'); const shootBtn = document.getElementById('shootBtn');
                leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.leftPressed = true; });
                leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameState.leftPressed = false; });
                rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.rightPressed = true; });
                rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameState.rightPressed = false; });
                shootBtn.addEventListener('touchstart', async (e) => {
                    e.preventDefault(); gameState.shootPressed = true;
                    if (gameState.paused) {
                        gameState.paused = false; document.getElementById('gameStartOverlay').style.display = 'none';
                        gameState.gameRunning = true; gameState.showUIScreen = false;
                        if (player.bonusWeaponRemainingOnPause > 0) { player.bonusWeaponEndTime = Date.now() + player.bonusWeaponRemainingOnPause; player.bonusWeaponActive = true; player.bonusWeaponRemainingOnPause = 0; }
                        pauseIcon.classList.remove('fa-play'); pauseIcon.classList.add('fa-pause');
                        if (isSoundOn) {
                            if (backgroundMusic.audioContext.state === 'suspended') { await backgroundMusic.audioContext.resume(); backgroundMusic.start(); backgroundMusic.setVolume(0.25); }
                            else { backgroundMusic.start(); backgroundMusic.setVolume(0.25); }
                        }
                    }
                });
                shootBtn.addEventListener('touchend', (e) => { e.preventDefault(); gameState.shootPressed = false; });
                leftBtn.addEventListener('mousedown', () => gameState.leftPressed = true);
                leftBtn.addEventListener('mouseup', () => gameState.leftPressed = false);
                rightBtn.addEventListener('mousedown', () => gameState.rightPressed = true);
                rightBtn.addEventListener('mouseup', () => gameState.rightPressed = false);
                shootBtn.addEventListener('mousedown', async () => {
                    gameState.shootPressed = true;
                    if (gameState.paused) {
                        gameState.paused = false; document.getElementById('gameStartOverlay').style.display = 'none';
                        gameState.gameRunning = true; gameState.showUIScreen = false;
                        if (player.bonusWeaponRemainingOnPause > 0) { player.bonusWeaponEndTime = Date.now() + player.bonusWeaponRemainingOnPause; player.bonusWeaponActive = true; player.bonusWeaponRemainingOnPause = 0; }
                        pauseIcon.classList.remove('fa-play'); pauseIcon.classList.add('fa-pause');
                        if (isSoundOn) {
                            if (backgroundMusic.audioContext.state === 'suspended') { await backgroundMusic.audioContext.resume(); backgroundMusic.start(); backgroundMusic.setVolume(0.25); }
                            else { backgroundMusic.start(); backgroundMusic.setVolume(0.25); }
                        }
                    }
                });
                shootBtn.addEventListener('mouseup', () => gameState.shootPressed = false);
                document.addEventListener('contextmenu', (e) => e.preventDefault());
                setupVirtualKeyboard();
            } else {
                document.getElementById('mobileControls').classList.remove('show');
                document.querySelectorAll('#gameStartOverlay .desktop-instruction').forEach(el => el.style.display = 'block');
                document.getElementById('gameStartOverlay').querySelector('#mobileStartInstructions').style.display = 'none';
            }
        }
        function setupVirtualKeyboard() {
            const keyboardDiv = document.getElementById('keyboard'); const keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const inputField = document.getElementById('initialsInput');
            keys.split('').forEach(key => {
                const btn = document.createElement('div'); btn.classList.add('key-btn'); btn.textContent = key;
                btn.addEventListener('click', () => { if (inputField.value.length < 3) inputField.value += key; });
                keyboardDiv.appendChild(btn);
            });
            const backspaceBtn = document.createElement('div'); backspaceBtn.classList.add('key-btn', 'backspace'); backspaceBtn.textContent = 'DEL';
            backspaceBtn.addEventListener('click', () => { inputField.value = inputField.value.slice(0, -1); });
            keyboardDiv.appendChild(backspaceBtn);
            const enterBtn = document.createElement('div'); enterBtn.classList.add('key-btn', 'enter'); enterBtn.textContent = 'ENTER';
            enterBtn.addEventListener('click', submitInitials); keyboardDiv.appendChild(enterBtn);
        }
        function animateTitle(elementId) {
            const titleElement = document.getElementById(elementId);
            const textSpans = titleElement.querySelectorAll('span:not(.rocket-icon)');
            textSpans.forEach((span, index) => {
                span.style.animation = 'rainbow-text 9s linear infinite';
                span.style.animationDelay = `${index * 0.0005}s`;
                span.style.setProperty('--hue-offset', `${index * 30}deg`);
                span.style.color = '';
            });
        }
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('submitInitialsBtn').addEventListener('click', submitInitials);
            document.getElementById('gameOverTitle').addEventListener('click', restartGame);
            document.getElementById('gameOverTitle').addEventListener('touchstart', restartGame);
            if (isSoundOn) { soundIcon.classList.remove('fa-volume-off'); soundIcon.classList.add('fa-volume-up'); }
            else { soundIcon.classList.remove('fa-volume-up'); soundIcon.classList.add('fa-volume-off'); }
            pauseIcon.classList.remove('fa-pause'); pauseIcon.classList.add('fa-play');
            animateTitle('gameTitle');
        });
        setupMobileControls();
        initFirebase().then(() => {
            initBackground(); createEnemies(); gameLoop();
        });
    </script>
</body>
</html>
